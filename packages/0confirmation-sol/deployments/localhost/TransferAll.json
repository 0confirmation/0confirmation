{
  "address": "0xf784709d2317D872237C4bC22f867d1BAe2913AB",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "execute",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "txData",
              "type": "bytes"
            }
          ],
          "internalType": "struct ShifterBorrowProxyLib.InitializationAction[]",
          "name": "",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "consData",
          "type": "bytes"
        }
      ],
      "name": "setup",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "target",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x2380d05e64b83eabc10591b3718c8c2e72ebdfdd178ab5fc3a6e4156b36c94a9",
  "receipt": {
    "to": null,
    "from": "0xc783df8a850f42e7F7e57013759C285caa701eB6",
    "contractAddress": "0xf784709d2317D872237C4bC22f867d1BAe2913AB",
    "transactionIndex": 0,
    "gasUsed": "443179",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x7f9d7b9aa281ba9fc9632b713080607fd964cac24469abe66bfbdf419689659d",
    "transactionHash": "0x2380d05e64b83eabc10591b3718c8c2e72ebdfdd178ab5fc3a6e4156b36c94a9",
    "logs": [],
    "blockNumber": 5,
    "cumulativeGasUsed": "443179",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "0x4ad71a06889361ed9ee42fc3cc3f9d59e654b4607e98c6d6bba47a63180890ff",
  "metadata": "{\"compiler\":{\"version\":\"0.6.10+commit.00c0fcaf\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"txData\",\"type\":\"bytes\"}],\"internalType\":\"struct ShifterBorrowProxyLib.InitializationAction[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"consData\",\"type\":\"bytes\"}],\"name\":\"setup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"target\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"methods\":{}},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"contracts/preprocessors/TransferAll.sol\":\"TransferAll\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/cryptography/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        // Check the signature length\\n        if (signature.length != 65) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        }\\n\\n        // Divide the signature in r, s and v variables\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // ecrecover takes the signature parameters, and the only way to get them\\n        // currently is to use assembly.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := byte(0, mload(add(signature, 0x60)))\\n        }\\n\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (281): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (282): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n\\n        if (v != 27 && v != 28) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        require(signer != address(0), \\\"ECDSA: invalid signature\\\");\\n\\n        return signer;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * replicates the behavior of the\\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\\n     * JSON-RPC method.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n}\\n\",\"keccak256\":\"0x1efcb1ccef6b3bce65467c4b704cec8d0582e35ff48352269ba8cda4b54ae3da\",\"license\":\"MIT\"},\"@openzeppelin/contracts/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\",\"keccak256\":\"0x9a9cf02622cd7a64261b10534fc3260449da25c98c9e96d1b4ae8110a20e5806\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x5c26b39d26f7ed489e555d955dcd3e01872972e71fdd1528e93ec164e4f23385\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Create2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\\n * `CREATE2` can be used to compute in advance the address where a smart\\n * contract will be deployed, which allows for interesting new mechanisms known\\n * as 'counterfactual interactions'.\\n *\\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\\n * information.\\n */\\nlibrary Create2 {\\n    /**\\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\\n     * will be deployed can be known in advance via {computeAddress}.\\n     *\\n     * The bytecode for a contract can be obtained from Solidity with\\n     * `type(contractName).creationCode`.\\n     *\\n     * Requirements:\\n     *\\n     * - `bytecode` must not be empty.\\n     * - `salt` must have not been used for `bytecode` already.\\n     * - the factory must have a balance of at least `amount`.\\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\\n     */\\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address) {\\n        address addr;\\n        require(address(this).balance >= amount, \\\"Create2: insufficient balance\\\");\\n        require(bytecode.length != 0, \\\"Create2: bytecode length is zero\\\");\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\\n        }\\n        require(addr != address(0), \\\"Create2: Failed on deploy\\\");\\n        return addr;\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\\n     * `bytecodeHash` or `salt` will result in a new destination address.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\\n        return computeAddress(salt, bytecodeHash, address(this));\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address) {\\n        bytes32 _data = keccak256(\\n            abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash)\\n        );\\n        return address(uint256(_data));\\n    }\\n}\\n\",\"keccak256\":\"0x16926b3c19504ea52f73abe41dfa9c1ef9c328d6088b82162d475caecaa47a6d\",\"license\":\"MIT\"},\"contracts/BorrowProxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma experimental ABIEncoderV2;\\npragma solidity ^0.6.0;\\n\\nimport { BorrowProxyLib } from \\\"./BorrowProxyLib.sol\\\";\\nimport { RevertCaptureLib } from \\\"./utils/RevertCaptureLib.sol\\\";\\nimport { SliceLib } from \\\"./utils/SliceLib.sol\\\";\\nimport { IShifter } from \\\"./interfaces/IShifter.sol\\\";\\nimport { IBorrowProxyController } from \\\"./interfaces/IBorrowProxyController.sol\\\";\\nimport { AddressSetLib } from \\\"./utils/AddressSetLib.sol\\\";\\nimport { ModuleLib } from \\\"./adapters/lib/ModuleLib.sol\\\";\\n\\ncontract BorrowProxy {\\n  using SliceLib for *;\\n  using BorrowProxyLib for *;\\n  using AddressSetLib for *;\\n  BorrowProxyLib.ProxyIsolate isolate;\\n  modifier onlyOwnerOrPool {\\n   require(msg.sender == isolate.owner || msg.sender == isolate.masterAddress || msg.sender == address(this), \\\"borrow proxy can only be used by borrower\\\");\\n    _;\\n  }\\n  function setup(address owner, address token, bool unbound) public returns (bool) {\\n    require(isolate.owner == address(0x0), \\\"can't initialize twice\\\");\\n    isolate.masterAddress = msg.sender;\\n    isolate.owner = owner;\\n    isolate.unbound = unbound;\\n    isolate.token = token;\\n    return true;\\n  }\\n  function validateProxyRecord(bytes memory record) internal returns (bool) {\\n    return IBorrowProxyController(isolate.masterAddress).validateProxyRecordHandler(record);\\n  }\\n  function proxy(address to, uint256 value, bytes memory payload) public onlyOwnerOrPool {\\n    require(to != isolate.masterAddress, \\\"can't target the ShifterPool\\\");\\n    bytes4 sig = bytes4(uint32(uint256(payload.toSlice(0, 4).asWord())));\\n    BorrowProxyLib.ModuleExecution memory module = isolate.fetchModule(to, sig);\\n    module.token = isolate.token;\\n    if (isolate.unbound && !module.encapsulated.isPrecompiled) {\\n      (bool success, bytes memory retval) = to.call{\\n        value: value\\n      }(payload);\\n      if (!success) revert(RevertCaptureLib.decodeError(retval));\\n      ModuleLib.bubbleResult(success, retval);\\n      return;\\n    }\\n    require(module.encapsulated.isDefined(), \\\"function handler not registered\\\");\\n    (bool success, bytes memory retval) = module.delegate(payload, value);\\n    if (!success) revert(RevertCaptureLib.decodeError(retval));\\n    if (module.encapsulated.liquidationSubmodule != address(0x0)) isolate.liquidationSet.insert(module.encapsulated.liquidationSubmodule);\\n    if (module.encapsulated.repaymentSubmodule != address(0x0)) {\\n      isolate.repaymentSet.insert(module.encapsulated.repaymentSubmodule);\\n    }\\n    ModuleLib.bubbleResult(success, retval);\\n  }\\n  receive() external payable virtual {\\n    // just receive ether, do nothing\\n  } \\n  fallback() external payable virtual {}\\n}\\n\",\"keccak256\":\"0x03d42cac11c2991b721b81bde53cf60542339ee279c1d420a1e5fb1254dadba9\",\"license\":\"MIT\"},\"contracts/BorrowProxyLib.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { Create2 } from \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\nimport { IModuleRegistryProvider } from \\\"./interfaces/IModuleRegistryProvider.sol\\\";\\nimport { AddressSetLib } from \\\"./utils/AddressSetLib.sol\\\";\\nimport { ExtLib } from \\\"./utils/ExtLib.sol\\\";\\nimport { RevertCaptureLib } from \\\"./utils/RevertCaptureLib.sol\\\";\\nimport { SandboxLib } from \\\"./utils/sandbox/SandboxLib.sol\\\";\\nimport { ModuleLib } from \\\"./adapters/lib/ModuleLib.sol\\\";\\n\\nlibrary BorrowProxyLib {\\n  using ModuleLib for *;\\n  struct ProxyIsolate {\\n    address payable masterAddress;\\n    bool unbound;\\n    address owner;\\n    address token;\\n    uint256 actualizedShift;\\n    uint256 liquidationIndex;\\n    uint256 repaymentIndex;\\n    bool isRepaying;\\n    bool isLiquidating;\\n    AddressSetLib.AddressSet liquidationSet;\\n    AddressSetLib.AddressSet repaymentSet;\\n  }\\n  struct ControllerIsolate {\\n    mapping (address => bytes32) proxyInitializerRecord;\\n    mapping (address => address) ownerByProxy;\\n    mapping (address => address) tokenByProxy;\\n    mapping (address => bool) isKeeper;\\n  }\\n  struct Module {\\n    bool isPrecompiled;\\n    address assetSubmodule;\\n    address liquidationSubmodule;\\n    address repaymentSubmodule;\\n  }\\n  struct ModuleDetails {\\n    ModuleRegistrationType moduleType;\\n    address target;\\n    bytes4[] sigs;\\n  }\\n  struct ModuleRegistration {\\n    ModuleRegistrationType moduleType;\\n    address target;\\n    bytes4[] sigs;\\n    Module module;\\n  }\\n  enum ModuleRegistrationType {\\n    UNINITIALIZED,\\n    BY_CODEHASH,\\n    BY_ADDRESS\\n  }\\n  struct ModuleExecution {\\n    address to;\\n    address token;\\n    Module encapsulated;\\n  }\\n  function registryRegisterModule(ModuleRegistry storage registry, ModuleRegistration memory registration) internal {\\n    if (registration.moduleType == ModuleRegistrationType.BY_CODEHASH) for (uint256 i = 0; i < registration.sigs.length; i++) {\\n      registerModuleByCodeHash(registry, registration.target, registration.sigs[i], registration.module);\\n    } else if (registration.moduleType == ModuleRegistrationType.BY_ADDRESS) for (uint256 i = 0; i < registration.sigs.length; i++) {\\n      registerModuleByAddress(registry, registration.target, registration.sigs[i], registration.module);\\n    }\\n  }\\n  function encodeLiquidate(address liquidationSubmodule) internal pure returns (bytes memory retval) {\\n    retval = abi.encodeWithSignature(\\\"liquidate(address)\\\", liquidationSubmodule);\\n  }\\n  function decodeBool(bytes memory input) internal pure returns (bool retval) {\\n    (retval) = abi.decode(input, (bool));\\n  }\\n  function delegateLiquidate(address liquidationSubmodule) internal returns (bool) {\\n    (bool success, bytes memory retval) = liquidationSubmodule.delegatecall(encodeLiquidate(liquidationSubmodule));\\n    if (!success) revert(RevertCaptureLib.decodeError(retval));\\n    return decodeBool(retval);\\n  }\\n  function encodeRepay(address repaymentSubmodule) internal pure returns (bytes memory retval) {\\n    retval = abi.encodeWithSignature(\\\"repay(address)\\\", repaymentSubmodule);\\n  }\\n  function delegateRepay(address repaymentSubmodule) internal returns (bool) {\\n    (bool success, bytes memory retval) = repaymentSubmodule.delegatecall(encodeRepay(repaymentSubmodule));\\n    if (!success) revert(RevertCaptureLib.decodeError(retval));\\n    return decodeBool(retval);\\n  }\\n  function encodeNotify(address liquidationSubmodule, bytes memory payload) internal pure returns (bytes memory retval) {\\n    retval = abi.encodeWithSignature(\\\"notify(address,bytes)\\\", liquidationSubmodule, payload);\\n  }\\n  function delegateNotify(address liquidationSubmodule, bytes memory payload) internal returns (bool) {\\n    (bool success,) = liquidationSubmodule.delegatecall(encodeNotify(liquidationSubmodule, payload));\\n    return success;\\n  }\\n  function delegate(ModuleExecution memory module, bytes memory payload, uint256 value) internal returns (bool, bytes memory) {\\n    (bool success, bytes memory retval) = module.encapsulated.assetSubmodule.delegatecall{ gas: gasleft() }(ModuleLib.AssetSubmodulePayload({\\n      moduleAddress: address(uint160(module.encapsulated.assetSubmodule)),\\n      liquidationSubmodule: module.encapsulated.liquidationSubmodule,\\n      repaymentSubmodule: module.encapsulated.repaymentSubmodule,\\n      token: address(uint160(module.token)),\\n      txOrigin: tx.origin,\\n      to: address(uint160(module.to)),\\n      value: value,\\n      callData: payload\\n    }).encodeWithSelector());\\n    return (success, retval);\\n  }\\n  function isDefined(Module memory module) internal pure returns (bool) {\\n    return module.assetSubmodule != address(0x0);\\n  }\\n  function isInitialized(ControllerIsolate storage isolate, address proxyAddress) internal view returns (bool) {\\n    return isolate.proxyInitializerRecord[proxyAddress] != bytes32(uint256(0x0));\\n  }\\n  struct ModuleRegistry {\\n    mapping (bytes32 => Module) modules;\\n  }\\n  function isDisbursing(ProxyIsolate storage isolate) internal view returns (bool) {\\n    return isolate.isLiquidating && isolate.liquidationIndex != isolate.liquidationSet.set.length;\\n  }\\n  event BorrowProxyMade(address indexed user, address indexed proxyAddress, bytes record);\\n  function emitBorrowProxyMade(address user, address proxyAddress, bytes memory record) internal {\\n    emit BorrowProxyMade(user, proxyAddress, record);\\n  }\\n  function computeModuleKeyPreimage(address to, bytes4 signature) internal pure returns (bytes memory result) {\\n    result = abi.encodePacked(to, signature);\\n  }\\n  function computeModuleKey(address to, bytes4 signature) internal pure returns (bytes32) {\\n    return keccak256(computeModuleKeyPreimage(to, signature));\\n  }\\n  function computeCodeResolverKeyPreimage(bytes32 codehash, bytes4 signature) internal pure returns (bytes memory result) {\\n    result = abi.encodePacked(codehash, signature);\\n  }\\n  function computeCodeResolverKey(address to, bytes4 signature) internal view returns (bytes32) {\\n    bytes32 exthash = ExtLib.getExtCodeHash(to);\\n    return keccak256(computeCodeResolverKeyPreimage(exthash, signature));\\n  }\\n  function resolveModule(ModuleRegistry storage registry, address to, bytes4 sig) internal view returns (Module memory) {\\n    Module memory module = registry.modules[computeCodeResolverKey(to, sig)];\\n    if (!isDefined(module)) module = registry.modules[computeModuleKey(to, sig)];\\n    return module;\\n  }\\n  function getModuleExecution(ModuleRegistry storage registry, address to, bytes4 signature) internal view returns (ModuleExecution memory) {\\n    Module memory encapsulated = resolveModule(registry, to, signature);\\n    return ModuleExecution({\\n      encapsulated: encapsulated,\\n      token: address(0x0), // fill in in the proxy call\\n      to: to\\n    });\\n  }\\n  function validateProxyRecord(ControllerIsolate storage isolate, address proxyAddress, bytes memory data) internal view returns (bool) {\\n    return isolate.proxyInitializerRecord[proxyAddress] == keccak256(data);\\n  }\\n  function mapProxyRecord(ControllerIsolate storage isolate, address proxyAddress, bytes memory data) internal {\\n    isolate.proxyInitializerRecord[proxyAddress] = keccak256(data);\\n  }\\n  function setProxyOwner(ControllerIsolate storage isolate, address proxyAddress, address identity) internal {\\n    isolate.ownerByProxy[proxyAddress] = identity;\\n  }\\n  function setProxyToken(ControllerIsolate storage isolate, address proxyAddress, address token) internal {\\n    isolate.tokenByProxy[proxyAddress] = token;\\n  }\\n  function getProxyToken(ControllerIsolate storage isolate, address proxyAddress) internal view returns (address) {\\n    return isolate.tokenByProxy[proxyAddress];\\n  }\\n  function getProxyOwner(ControllerIsolate storage isolate, address proxyAddress) internal view returns (address) {\\n    return isolate.ownerByProxy[proxyAddress];\\n  }\\n  function registerModuleByAddress(ModuleRegistry storage registry, address to, bytes4 signature, Module memory module) internal {\\n    registry.modules[computeModuleKey(to, signature)] = module;\\n  }\\n  function registerModuleByCodeHash(ModuleRegistry storage registry, address to, bytes4 signature, Module memory module) internal {\\n    registry.modules[computeCodeResolverKey(to, signature)] = module;\\n  }\\n  function fetchModule(ProxyIsolate storage isolate, address to, bytes4 signature) internal returns (ModuleExecution memory) {\\n    return ModuleExecution({\\n      encapsulated: IModuleRegistryProvider(isolate.masterAddress).fetchModuleHandler(to, signature),\\n      token: isolate.token,\\n      to: to\\n    });\\n  }\\n}\\n\",\"keccak256\":\"0xec2de85244c570599f4c128c83ffdbe413b6f44c81cd59eb0f244b6686e4700b\",\"license\":\"MIT\"},\"contracts/ShifterBorrowProxyLib.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { IInitializationActionsReceiver } from \\\"./interfaces/IInitializationActionsReceiver.sol\\\";\\nimport { ECDSA } from \\\"@openzeppelin/contracts/cryptography/ECDSA.sol\\\";\\nimport { SafeMath } from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport { BorrowProxy } from \\\"./BorrowProxy.sol\\\";\\nimport { BorrowProxyLib } from \\\"./BorrowProxyLib.sol\\\";\\nimport { TokenUtils } from \\\"./utils/TokenUtils.sol\\\";\\nimport { RevertCaptureLib } from \\\"./utils/RevertCaptureLib.sol\\\";\\nimport { SandboxLib } from \\\"./utils/sandbox/SandboxLib.sol\\\";\\nimport { IShifter } from \\\"./interfaces/IShifter.sol\\\";\\nimport { IShifterERC20 } from \\\"./interfaces/IShifterERC20.sol\\\";\\n\\nlibrary ShifterBorrowProxyLib {\\n  using SafeMath for *;\\n  using TokenUtils for *;\\n  struct ProxyRecord {\\n    LiquidityRequest request;\\n    LenderRecord loan;\\n    uint256 expected;\\n  }\\n  struct LiquidityRequest {\\n    address payable borrower;\\n    address token;\\n    bytes32 nonce;\\n    uint256 amount;\\n    bool forbidLoan;\\n    InitializationAction[] actions;\\n  }\\n  struct InitializationAction {\\n    address to;\\n    bytes txData;\\n  }\\n  event BorrowProxyInitialization(address indexed proxyAddress, SandboxLib.ProtectedExecution[]);\\n  function emitBorrowProxyInitialization(address /* proxyAddress */, SandboxLib.ProtectedExecution[] memory /* trace */) internal {\\n//    emit BorrowProxyInitialization(proxyAddress, trace);\\n  }\\n    \\n  function encodeProxyRecord(ProxyRecord memory record) internal pure returns (bytes memory result) {\\n    result = abi.encode(record);\\n  }\\n  function decodeProxyRecord(bytes memory record) internal pure returns (ProxyRecord memory result) {\\n    (result) = abi.decode(record, (ProxyRecord));\\n  }\\n  struct LiquidityRequestParcel {\\n    LiquidityRequest request;\\n    uint256 gasRequested;\\n    bytes signature;\\n  }\\n  function computeDepositAddress(LiquidityRequestParcel memory /* parcel */, address /* mpkh */, bool /* btcTestnet */) internal pure returns (string memory result) {\\n    result = \\\"\\\";\\n  }\\n  struct LenderParams {\\n    uint256 timeoutExpiry;\\n    uint256 bond;\\n    uint256 poolFee;\\n    uint256 keeperFee;\\n  }\\n  struct LenderRecord {\\n    address keeper;\\n    LenderParams params;\\n  }\\n  event ShifterBorrowProxyRepaid(address indexed user, ProxyRecord record);\\n  function emitShifterBorrowProxyRepaid(address user, ProxyRecord memory record) internal {\\n    emit ShifterBorrowProxyRepaid(user, record);\\n  }\\n  function encodeBorrowerMessage(LiquidityRequest memory params, bytes memory parcelActionsEncoded) internal pure returns (bytes memory result) {\\n    result = abi.encodePacked(params.borrower, params.token, params.nonce, params.amount, params.forbidLoan, parcelActionsEncoded);\\n  }\\n  function computeBorrowerSalt(LiquidityRequest memory params) internal pure returns (bytes32 result) {\\n    result = keccak256(computeBorrowerSaltPreimage(params));\\n  }\\n  function computeBorrowerSaltPreimage(LiquidityRequest memory params) internal pure returns (bytes memory result) {\\n    bytes memory parcelActionsEncoded = encodeParcelActions(params.actions);\\n    result = encodeBorrowerMessage(params, parcelActionsEncoded);\\n  }\\n  function encodeParcelActions(InitializationAction[] memory actions) internal pure returns (bytes memory retval) {\\n    retval = abi.encode(actions);\\n  }\\n  function computeLiquidityRequestParcelMessage(LiquidityRequestParcel memory parcel, bytes memory parcelActionsEncoded) internal view returns (bytes memory retval) {\\n    retval = abi.encodePacked(address(this), parcel.request.token, parcel.request.nonce, parcel.request.amount, parcel.gasRequested, parcel.request.forbidLoan, parcelActionsEncoded);\\n  }\\n  function computeLiquidityRequestPreimage(LiquidityRequestParcel memory parcel) internal view returns (bytes memory result) {\\n    bytes memory parcelActionsEncoded = encodeParcelActions(parcel.request.actions);\\n    result = computeLiquidityRequestParcelMessage(parcel, parcelActionsEncoded);\\n  }\\n  function computeLiquidityRequestHash(LiquidityRequestParcel memory parcel) internal view returns (bytes32 result) {\\n    result = keccak256(computeLiquidityRequestPreimage(parcel));\\n  }\\n  function validateSignature(LiquidityRequestParcel memory parcel, bytes32 hash) internal pure returns (bool) {\\n    return parcel.request.borrower == ECDSA.recover(ECDSA.toEthSignedMessageHash(hash), parcel.signature);\\n  }\\n  function validateSignature(LiquidityRequestParcel memory parcel) internal view returns (bool) {\\n    return parcel.request.borrower == ECDSA.recover(ECDSA.toEthSignedMessageHash(computeLiquidityRequestHash(parcel)), parcel.signature);\\n  }\\n  struct ShiftParameters {\\n    bytes32 txhash;\\n    uint256 vout;\\n    bytes32 pHash;\\n    uint256 amount;\\n    bytes darknodeSignature;\\n  }\\n  struct TriggerParcel {\\n    ProxyRecord record;\\n    ShiftParameters shiftParameters;\\n  }\\n  struct SansBorrowShiftParcel {\\n    LiquidityRequestParcel liquidityRequestParcel;\\n    ShiftParameters shiftParameters;\\n    InitializationAction[] actions;\\n  }\\n  function decodeTriggerParcel(bytes memory parcel) internal pure returns (TriggerParcel memory result) {\\n    (result) = abi.decode(parcel, (TriggerParcel));\\n  }\\n  function encodeNPreimage(TriggerParcel memory parcel) internal pure returns (bytes memory result) {\\n    result = abi.encodePacked(parcel.record.request.nonce, parcel.shiftParameters.txhash, parcel.shiftParameters.vout);\\n  }\\n  function computeNHash(TriggerParcel memory parcel) internal pure returns (bytes32) {\\n    return keccak256(encodeNPreimage(parcel));\\n  }\\n  uint256 constant BIPS_DENOMINATOR = 10000;\\n  function computeExpectedAmount(uint256 amount, address shifter, address token) internal returns (uint256 expected) {\\n    uint256 mintFee = getMintFee(shifter);\\n    uint256 underlyingAmount = getUnderlyingAmount(token, amount);\\n    uint256 fee = underlyingAmount.mul(mintFee).div(BIPS_DENOMINATOR);\\n    expected = underlyingAmount.sub(fee);\\n  }\\n  function getMintFee(address shifter) internal view returns (uint256 mintFee) {\\n    mintFee = uint256(IShifter(shifter).mintFee());\\n  }\\n  function getUnderlyingAmount(address token, uint256 amount) internal returns (uint256 underlyingAmount) {\\n    underlyingAmount = IShifterERC20(token).fromUnderlying(amount);\\n  }\\n  function computePostFee(ProxyRecord memory record) internal pure returns (uint256) {\\n    return record.expected.sub(computePoolFee(record).add(computeKeeperFee(record)));\\n  }\\n  function computePoolFee(ProxyRecord memory record) internal pure returns (uint256) {\\n    return record.expected.mul(record.loan.params.poolFee).div(uint256(1 ether));\\n  }\\n  function computeKeeperFee(ProxyRecord memory record) internal pure returns (uint256) {\\n    return record.expected.mul(record.loan.params.keeperFee).div(uint256(1 ether));\\n  }\\n  function computeAdjustedKeeperFee(ProxyRecord memory record, uint256 actual) internal pure returns (uint256) {\\n    return actual.mul(record.loan.params.keeperFee).div(uint256(1 ether));\\n  }\\n}\\n\",\"keccak256\":\"0x974cd03066104f482be120f08df210b740c6262207e249850db2374ed48d1a97\",\"license\":\"MIT\"},\"contracts/adapters/lib/ModuleLib.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { SliceLib } from \\\"../../utils/SliceLib.sol\\\";\\n\\ninterface IModule {\\n  function handle(ModuleLib.AssetSubmodulePayload calldata) external payable;\\n}\\n\\nlibrary ModuleLib {\\n  address payable constant ETHER_ADDRESS = 0x0000000000000000000000000000000000000000;\\n  function GET_ETHER_ADDRESS() internal pure returns (address payable) {\\n    return ETHER_ADDRESS;\\n  }\\n  function cast(uint256 v) internal pure returns (uint256) {\\n    return v;\\n  }\\n  function splitPayload(bytes memory payload) internal pure returns (bytes4 sig, bytes memory args) {\\n    sig = bytes4(uint32(uint256(SliceLib.asWord(SliceLib.toSlice(payload, 0, 4)))));\\n    args = SliceLib.copy(SliceLib.toSlice(payload, 4));\\n  }\\n  struct AssetSubmodulePayload {\\n    address payable moduleAddress;\\n    address liquidationSubmodule;\\n    address repaymentSubmodule;\\n    address payable token;\\n    address payable txOrigin;\\n    address payable to;\\n    uint256 value;\\n    bytes callData;\\n  }\\n  function encodeWithSelector(AssetSubmodulePayload memory input) internal pure returns (bytes memory result) {\\n    result = abi.encodeWithSelector(IModule.handle.selector, input);\\n  }\\n  function bubbleResult(bool success, bytes memory retval) internal pure {\\n    assembly {\\n      if iszero(success) {\\n        revert(add(0x20, retval), mload(retval))\\n      }\\n      return(add(0x20, retval), mload(retval))\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x03885b4abdb3ce947222c3b8b8c6ab0ee3f34e9f4bcd6dea723c8eecb7de69d5\",\"license\":\"MIT\"},\"contracts/interfaces/IBorrowProxyController.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\ninterface IBorrowProxyController {\\n  function getProxyOwnerHandler() external returns (address);\\n  function validateProxyRecordHandler(bytes calldata) external returns (bool);\\n}\\n\",\"keccak256\":\"0x7b767728648d1fe8fff17648e5b8791b3939d6de13c27f6d7e12b14fbccca381\",\"license\":\"MIT\"},\"contracts/interfaces/IInitializationActionsReceiver.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { SandboxLib } from \\\"../utils/sandbox/SandboxLib.sol\\\";\\nimport { ShifterBorrowProxyLib } from \\\"../ShifterBorrowProxyLib.sol\\\";\\n\\ninterface IInitializationActionsReceiver {\\n  function receiveInitializationActions(ShifterBorrowProxyLib.InitializationAction[] calldata actions) external returns (SandboxLib.Context memory context);\\n}\\n\",\"keccak256\":\"0x3b99602cbca2e9a92feae53362b85b47541d1e47ea4e283a78c08001b152d8f1\",\"license\":\"MIT\"},\"contracts/interfaces/IModuleRegistryProvider.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { BorrowProxyLib } from \\\"../BorrowProxyLib.sol\\\";\\n\\ninterface IModuleRegistryProvider {\\n  function fetchModuleHandler(address to, bytes4 sig) external returns (BorrowProxyLib.Module memory);\\n}\\n\",\"keccak256\":\"0x792268c81b8385756e08f08699301caf506a887c2c899d069b25cfeb4341e1f6\",\"license\":\"MIT\"},\"contracts/interfaces/IShifter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\ninterface IShifter {\\n  function mint(bytes32 _pHash, uint256 _amount, bytes32 _nHash, bytes calldata _sig) external returns (uint256);\\n  function mintFee() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x26475c55e8f35728e04b0b61a5dbaca020f9ce02bbac1d02b0ddf2ff4fdcadf7\",\"license\":\"MIT\"},\"contracts/interfaces/IShifterERC20.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\ninterface IShifterERC20 {\\n  function fromUnderlying(uint256 amount) external returns (uint256);\\n}\\n  \\n\",\"keccak256\":\"0x7bcb210ac3d6e55d793b9f16c24defd8bd32337f94f9ae25bc49124f7efcdd09\",\"license\":\"MIT\"},\"contracts/preprocessors/TransferAll.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { PreprocessorLib } from \\\"./lib/PreprocessorLib.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { ShifterBorrowProxyLib } from \\\"../ShifterBorrowProxyLib.sol\\\";\\nimport { SandboxLib } from \\\"../utils/sandbox/SandboxLib.sol\\\";\\nimport { BorrowProxyLib } from \\\"../BorrowProxyLib.sol\\\";\\n\\ncontract TransferAll {\\n  using PreprocessorLib for *;\\n  BorrowProxyLib.ProxyIsolate isolate;\\n  address public target;\\n  function setup(bytes memory consData) public {\\n    (target) = abi.decode(consData, (address));\\n  }\\n  function execute(bytes memory data) view public returns (ShifterBorrowProxyLib.InitializationAction[] memory) {\\n    SandboxLib.ExecutionContext memory context = data.toContext();\\n    address token = isolate.token;\\n    return isolate.token.sendTransaction(abi.encodeWithSelector(IERC20.transfer.selector, TransferAll(context.preprocessorAddress).target(), IERC20(token).balanceOf(address(this))));\\n  }\\n}\\n\",\"keccak256\":\"0xcc671b4fe8226962c328293086c1a373f1fc2a8926533df3bee12867971e1e7f\",\"license\":\"MIT\"},\"contracts/preprocessors/lib/PreprocessorLib.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { SandboxLib } from \\\"../../utils/sandbox/SandboxLib.sol\\\";\\nimport { ShifterBorrowProxyLib } from \\\"../../ShifterBorrowProxyLib.sol\\\";\\n\\nlibrary PreprocessorLib {\\n  function toContext(bytes memory input) internal pure returns (SandboxLib.ExecutionContext memory) {\\n    return SandboxLib.toContext(input);\\n  }\\n  function then(ShifterBorrowProxyLib.InitializationAction memory action, ShifterBorrowProxyLib.InitializationAction memory nextAction) internal pure returns (ShifterBorrowProxyLib.InitializationAction[] memory result) {\\n    result = new ShifterBorrowProxyLib.InitializationAction[](2);\\n    result[0] = action;\\n    result[1] = nextAction;\\n  }\\n  function getLastExecution(SandboxLib.Context memory context) internal pure returns (bool foundLast, SandboxLib.ProtectedExecution memory execution) {\\n    if (context.trace.length == 0) return (foundLast, execution);\\n    SandboxLib.ProtectedExecution[] memory lastBatch = context.trace[context.trace.length - 1];\\n    execution = lastBatch[lastBatch.length - 1];\\n  }\\n  function then(ShifterBorrowProxyLib.InitializationAction[] memory actions, ShifterBorrowProxyLib.InitializationAction[] memory nextActions) internal pure returns (ShifterBorrowProxyLib.InitializationAction[] memory result) {\\n    result = new ShifterBorrowProxyLib.InitializationAction[](actions.length + nextActions.length);\\n    uint256 i = 0;\\n    for (; i < actions.length; i++) {\\n      result[i] = actions[i];\\n    }\\n    for (uint256 j = 0; j < nextActions.length; j++) {\\n      result[i] = nextActions[j];\\n      i++;\\n    }\\n  }\\n  function then(ShifterBorrowProxyLib.InitializationAction[] memory actions, ShifterBorrowProxyLib.InitializationAction memory nextAction) internal pure returns (ShifterBorrowProxyLib.InitializationAction[] memory result) {\\n    result = then(actions, toList(nextAction));\\n  }\\n  function toList(ShifterBorrowProxyLib.InitializationAction memory input) internal pure returns (ShifterBorrowProxyLib.InitializationAction[] memory result) {\\n    result = new ShifterBorrowProxyLib.InitializationAction[](1);\\n    result[0] = input;\\n  }\\n  function sendTransaction(address to, bytes memory txData) internal pure returns (ShifterBorrowProxyLib.InitializationAction[] memory result) {\\n    return toList(ShifterBorrowProxyLib.InitializationAction({\\n      to: to,\\n      txData: txData\\n    }));\\n  }\\n}\\n\",\"keccak256\":\"0x4a68c135a40b0ff83c289d6a4e292bd0cbdc292b3e420c5f92958c16add43121\",\"license\":\"MIT\"},\"contracts/utils/AddressSetLib.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nlibrary AddressSetLib {\\n  struct AddressSet {\\n    mapping (address => bool) uniq;\\n    address[] set;\\n  }\\n  function insert(AddressSet storage addressSet, address item) internal {\\n    if (addressSet.uniq[item]) return;\\n    addressSet.set.push(item);\\n  }\\n  function get(AddressSet storage addressSet, uint256 i) internal view returns (address) {\\n    return addressSet.set[i];\\n  }\\n  function size(AddressSet storage addressSet) internal view returns (uint256) {\\n    return addressSet.set.length;\\n  }\\n}\\n\",\"keccak256\":\"0x5b5e060c2825541a6bd9372e33adba3ab8451642d022922184f51ab87cf33fce\",\"license\":\"MIT\"},\"contracts/utils/ExtLib.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nlibrary ExtLib {\\n  function getExtCodeHash(address target) internal view returns (bytes32 result) {\\n    assembly {\\n      result := extcodehash(target)\\n    }\\n  }\\n  function isContract(address target) internal view returns (bool result) {\\n    assembly {\\n      result := iszero(iszero(extcodesize(target)))\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0xc7de2388e172afde1e93560f451bd6215f411a7ed51cdb750cbc17617173cd57\",\"license\":\"MIT\"},\"contracts/utils/MemcpyLib.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nlibrary MemcpyLib {\\n  function memcpy(bytes32 dest, bytes32 src, uint256 len) internal pure {\\n    assembly {\\n      for {} iszero(lt(len, 0x20)) { len := sub(len, 0x20) } {\\n        mstore(dest, mload(src))\\n        dest := add(dest, 0x20)\\n        src := add(src, 0x20)\\n      }\\n      let mask := sub(shl(mul(sub(32, len), 8), 1), 1)\\n      mstore(dest, or(and(mload(src), not(mask)), and(mload(dest), mask)))\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x6692972a7b1f397575ce10ab8652b92337ae9b30fda75c7648acb6c309d7dbf0\",\"license\":\"MIT\"},\"contracts/utils/RevertCaptureLib.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { SliceLib } from \\\"./SliceLib.sol\\\";\\n\\nlibrary RevertCaptureLib {\\n  using SliceLib for *;\\n  uint32 constant REVERT_WITH_REASON_MAGIC = 0x08c379a0; // keccak256(\\\"Error(string)\\\")\\n  function decodeString(bytes memory input) internal pure returns (string memory retval) {\\n    (retval) = abi.decode(input, (string));\\n  }\\n  function decodeError(bytes memory buffer) internal pure returns (string memory) {\\n    if (buffer.length == 0) return \\\"captured empty revert buffer\\\";\\n    if (uint32(uint256(bytes32(buffer.toSlice(0, 4).asWord()))) != REVERT_WITH_REASON_MAGIC) return \\\"captured a revert error, but it doesn't conform to the standard\\\";\\n    bytes memory revertMessageEncoded = buffer.toSlice(4).copy();\\n    if (revertMessageEncoded.length == 0) return \\\"captured empty revert message\\\";\\n    (string memory revertMessage) = decodeString(revertMessageEncoded);\\n    return revertMessage;\\n  }\\n}\\n\",\"keccak256\":\"0x03a939369019394c9ddb4e79e0a4b90c4f5d8e398ff5db501c9f9d4ee68997c5\",\"license\":\"MIT\"},\"contracts/utils/SliceLib.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { MemcpyLib } from \\\"./MemcpyLib.sol\\\";\\n\\nlibrary SliceLib {\\n  struct Slice {\\n    uint256 data;\\n    uint256 length;\\n    uint256 offset;\\n  }\\n  function toPtr(bytes memory input, uint256 offset) internal pure returns (uint256 data) {\\n    assembly {\\n      data := add(input, add(offset, 0x20))\\n    }\\n  }\\n  function toSlice(bytes memory input, uint256 offset, uint256 length) internal pure returns (Slice memory retval) {\\n    retval.data = toPtr(input, offset);\\n    retval.length = length;\\n    retval.offset = offset;\\n  }\\n  function toSlice(bytes memory input) internal pure returns (Slice memory) {\\n    return toSlice(input, 0);\\n  }\\n  function toSlice(bytes memory input, uint256 offset) internal pure returns (Slice memory) {\\n    if (input.length < offset) offset = input.length;\\n    return toSlice(input, offset, input.length - offset);\\n  }\\n  function toSlice(Slice memory input, uint256 offset, uint256 length) internal pure returns (Slice memory) {\\n    return Slice({\\n      data: input.data + offset,\\n      offset: input.offset + offset,\\n      length: length\\n    });\\n  }\\n  function toSlice(Slice memory input, uint256 offset) internal pure returns (Slice memory) {\\n    return toSlice(input, offset, input.length - offset);\\n  }\\n  function toSlice(Slice memory input) internal pure returns (Slice memory) {\\n    return toSlice(input, 0);\\n  }\\n  function maskLastByteOfWordAt(uint256 data) internal pure returns (uint8 lastByte) {\\n    assembly {\\n      lastByte := and(mload(data), 0xff)\\n    }\\n  }\\n  function get(Slice memory slice, uint256 index) internal pure returns (bytes1 result) {\\n    return bytes1(maskLastByteOfWordAt(slice.data - 0x1f + index));\\n  }\\n  function setByteAt(uint256 ptr, uint8 value) internal pure {\\n    assembly {\\n      mstore8(ptr, value)\\n    }\\n  }\\n  function set(Slice memory slice, uint256 index, uint8 value) internal pure {\\n    setByteAt(slice.data + index, value);\\n  }\\n  function wordAt(uint256 ptr, uint256 length) internal pure returns (bytes32 word) {\\n    assembly {\\n      let mask := sub(shl(mul(length, 0x8), 0x1), 0x1)\\n      word := and(mload(sub(ptr, sub(0x20, length))), mask)\\n    }\\n  }\\n  function asWord(Slice memory slice) internal pure returns (bytes32 word) {\\n    uint256 data = slice.data;\\n    uint256 length = slice.length;\\n    return wordAt(data, length);\\n  }\\n  function toDataStart(bytes memory input) internal pure returns (bytes32 start) {\\n    assembly {\\n      start := add(input, 0x20)\\n    }\\n  }\\n  function copy(Slice memory slice) internal pure returns (bytes memory retval) {\\n    uint256 length = slice.length;\\n    retval = new bytes(length);\\n    bytes32 src = bytes32(slice.data);\\n    bytes32 dest = toDataStart(retval);\\n    MemcpyLib.memcpy(dest, src, length);\\n  }\\n  function keccakAt(uint256 data, uint256 length) internal pure returns (bytes32 result) {\\n    assembly {\\n      result := keccak256(data, length)\\n    }\\n  }\\n  function toKeccak(Slice memory slice) internal pure returns (bytes32 result) {\\n    return keccakAt(slice.data, slice.length);\\n  }\\n}\\n\",\"keccak256\":\"0xde40e25d2efd85a714714a080b7d62b3633effa0613d4ca7831a5abbf70180d3\",\"license\":\"MIT\"},\"contracts/utils/StringLib.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nlibrary StringLib {\\n    /// @notice Convert a uint value to its decimal string representation\\n    // solium-disable-next-line security/no-assign-params\\n    function toString(uint256 _i) internal pure returns (string memory) {\\n        if (_i == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 j = _i;\\n        uint256 len;\\n        while (j != 0) {\\n            len++;\\n            j /= 10;\\n        }\\n        bytes memory bstr = new bytes(len);\\n        uint256 k = len - 1;\\n        while (_i != 0) {\\n            bstr[k--] = bytes1(uint8(48 + (_i % 10)));\\n            _i /= 10;\\n        }\\n        return string(bstr);\\n    }\\n\\n    /// @notice Convert a bytes32 value to its hex string representation\\n    function toString(bytes32 _value) internal pure returns (string memory) {\\n        bytes memory alphabet = \\\"0123456789abcdef\\\";\\n\\n        bytes memory str = new bytes(32 * 2 + 2);\\n        str[0] = \\\"0\\\";\\n        str[1] = \\\"x\\\";\\n        for (uint256 i = 0; i < 32; i++) {\\n            str[2 + i * 2] = alphabet[uint256(uint8(_value[i] >> 4))];\\n            str[3 + i * 2] = alphabet[uint256(uint8(_value[i] & 0x0f))];\\n        }\\n        return string(str);\\n    }\\n\\n    /// @notice Convert an address to its hex string representation\\n    function toString(address _addr) internal pure returns (string memory) {\\n        bytes32 value = bytes32(uint256(_addr));\\n        bytes memory alphabet = \\\"0123456789abcdef\\\";\\n\\n        bytes memory str = new bytes(20 * 2 + 2);\\n        str[0] = \\\"0\\\";\\n        str[1] = \\\"x\\\";\\n        for (uint256 i = 0; i < 20; i++) {\\n            str[2 + i * 2] = alphabet[uint256(uint8(value[i + 12] >> 4))];\\n            str[3 + i * 2] = alphabet[uint256(uint8(value[i + 12] & 0x0f))];\\n        }\\n        return string(str);\\n    }\\n    function toString(bytes memory input) internal pure returns (string memory) {\\n      return string(input);\\n    }\\n}\\n\",\"keccak256\":\"0xe9996ac71f9b093c2857d86d1480d2698c5ad5e37dc7a6d0f425e53721c51091\",\"license\":\"MIT\"},\"contracts/utils/TokenUtils.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nlibrary TokenUtils {\\n  function encodeTransfer(address target, uint256 amount) internal pure returns (bytes memory retval) {\\n    retval = abi.encodeWithSelector(IERC20.transfer.selector, target, amount);\\n  }\\n  function sendToken(address token, address target, uint256 amount) internal returns (bool) {\\n    (bool success,) = token.call(encodeTransfer(target, amount));\\n    return success;\\n  }\\n  function encodeTransferFrom(address from, address to, uint256 amount) internal pure returns (bytes memory retval) {\\n    retval = abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, amount);\\n  }\\n  function transferTokenFrom(address token, address from, address to, uint256 amount) internal returns (bool) {\\n    (bool success,) = token.call(encodeTransferFrom(from, to, amount));\\n    return success;\\n  }\\n  function encodeApproval(address target, uint256 amount) internal pure returns (bytes memory retval) {\\n    retval = abi.encodeWithSelector(IERC20.approve.selector, target, amount);\\n  }\\n  function approveToken(address token, address target, uint256 amount) internal returns (bool) {\\n    (bool success,) = token.call(encodeApproval(target, amount));\\n    return success;\\n  }\\n  uint256 constant THRESHOLD = 0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\n  uint256 constant MAX_UINT256 = 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\n  function approveForMaxIfNeeded(address token, address target) internal returns (bool) {\\n    uint256 approved = getApproved(token, address(this), target);\\n    if (approved > THRESHOLD) return true;\\n    if (approved != 0 && !approveToken(token, address(this), 0)) return false;\\n    return approveToken(token, target, MAX_UINT256);\\n  }\\n  function encodeAllowance(address source, address target) internal pure returns (bytes memory retval) {\\n    retval = abi.encodeWithSelector(IERC20.allowance.selector, source, target);\\n  }\\n  function decodeUint(bytes memory input) internal pure returns (uint256 retval) {\\n    (retval) = abi.decode(input, (uint256));\\n  }\\n  function getApproved(address token, address source, address target) internal returns (uint256) {\\n    (bool success, bytes memory retval) = token.call(encodeAllowance(source, target));\\n    if (!success || retval.length != 0x20) return 0x1;\\n    return decodeUint(retval);\\n  }\\n}\\n\",\"keccak256\":\"0x4fbca09a038a8272ad9e8cf05c818c376c27720e37c8924e846966f0f9d8016c\",\"license\":\"MIT\"},\"contracts/utils/sandbox/ISafeView.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\ninterface ISafeView {\\n  function execute(bytes calldata) external;\\n  function _executeSafeView(bytes calldata, bytes calldata) external;\\n}\\n\",\"keccak256\":\"0x5c6a466fb34671be27998d54ec8b11c5e9320fcd680ecd6c1363004bf0bca0f4\",\"license\":\"MIT\"},\"contracts/utils/sandbox/SafeViewLib.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { ISafeView } from \\\"./ISafeView.sol\\\";\\nimport { Create2 } from \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\n\\nlibrary SafeViewLib {\\n  struct SafeViewResult {\\n    bool success;\\n    bytes data;\\n  }\\n  function executeLogic(address viewLayer, bytes memory context) internal returns (SafeViewResult memory) {\\n    (bool success, bytes memory retval) = viewLayer.delegatecall(encodeExecute(context));\\n    return SafeViewResult({\\n      success: success,\\n      data: retval\\n    });\\n  }\\n  function encodeResult(SafeViewResult memory input) internal pure returns (bytes memory retval) {\\n    retval = abi.encode(input);\\n  }\\n  function revertWithData(bytes memory input) internal pure {\\n    assembly {\\n      revert(add(input, 0x20), mload(input))\\n    }\\n  }\\n  function decodeViewResult(bytes memory data) internal pure returns (SafeViewResult memory result) {\\n     (result) = abi.decode(data, (SafeViewResult));\\n   }\\n   function encodeExecuteSafeView(bytes memory creationCode, bytes memory context) internal pure returns (bytes memory retval) {\\n     retval = abi.encodeWithSelector(ISafeView._executeSafeView.selector, creationCode, context);\\n   }\\n   function encodeExecute(bytes memory context) internal pure returns (bytes memory retval) {\\n     retval = abi.encodeWithSelector(ISafeView.execute.selector, context);\\n   }\\n  function safeView(bytes memory creationCode, bytes memory context) internal returns (SafeViewLib.SafeViewResult memory) {\\n    (/* bool success */, bytes memory retval) = address(this).call(encodeExecuteSafeView(creationCode, context));\\n    return decodeViewResult(retval);\\n  }\\n  bytes32 constant STEALTH_VIEW_DEPLOY_SALT = 0xad53495153c7c363e98a26920ec679e0e687636458f6908c91cf6deadb190801;\\n  function GET_STEALTH_VIEW_DEPLOY_SALT() internal pure returns (bytes32) {\\n    return STEALTH_VIEW_DEPLOY_SALT;\\n  }\\n  function deriveViewAddress(bytes memory creationCode) internal view returns (address) {\\n    return Create2.computeAddress(STEALTH_VIEW_DEPLOY_SALT, keccak256(creationCode));\\n  }\\n}\\n\",\"keccak256\":\"0xa274f8262ba1e34d13f58f0bc29f12bdc43d19b7c8c3dc3b259566faed3a40ff\",\"license\":\"MIT\"},\"contracts/utils/sandbox/SandboxLib.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { SliceLib } from \\\"../SliceLib.sol\\\";\\nimport { SafeViewLib } from \\\"./SafeViewLib.sol\\\";\\nimport { BorrowProxy } from \\\"../../BorrowProxy.sol\\\";\\nimport { ShifterBorrowProxyLib } from \\\"../../ShifterBorrowProxyLib.sol\\\";\\nimport { RevertCaptureLib } from \\\"../../utils/RevertCaptureLib.sol\\\";\\nimport { PreprocessorLib } from \\\"../../preprocessors/lib/PreprocessorLib.sol\\\";\\nimport { StringLib } from \\\"../../utils/StringLib.sol\\\";\\n\\nlibrary SandboxLib {\\n  using SafeViewLib for *;\\n  using SliceLib for *;\\n  using StringLib for *;\\n  using PreprocessorLib for *;\\n  struct ProtectedExecution {\\n    address to;\\n    bytes txData;\\n    bool success;\\n    bytes returnData;\\n  }\\n  function applyExecutionResult(ProtectedExecution[][] memory trace, uint256 index, ShifterBorrowProxyLib.InitializationAction[] memory preprocessed) internal pure returns (bool) {\\n    ProtectedExecution[] memory execution = new ProtectedExecution[](preprocessed.length);\\n    for (uint256 i = 0; i < execution.length; i++) {\\n      execution[i].txData = preprocessed[i].txData;\\n      execution[i].to = preprocessed[i].to;\\n    }\\n    trace[index] = execution;\\n    return execution.length != 0;\\n  }\\n  struct Context {\\n    address preprocessorAddress;\\n    ProtectedExecution[][] trace;\\n  }\\n  function encodeContext(ExecutionContext memory input) internal pure returns (bytes memory context) {\\n    context = abi.encode(input);\\n  }\\n  function toContext(bytes memory input) internal pure returns (ExecutionContext memory context) {\\n    (context) = abi.decode(input, (ExecutionContext));\\n  }\\n  function _write(ProtectedExecution[][] memory trace, uint256 newSize) internal pure {\\n    assembly {\\n      mstore(trace, newSize)\\n    }\\n  }\\n  function _restrict(Context memory context) internal pure {\\n    _write(context.trace, 0);\\n  }\\n  function _grow(Context memory context) internal pure {\\n    ProtectedExecution[][] memory trace = context.trace;\\n    uint256 newSize = trace.length;\\n    _write(trace, newSize + 1);\\n  }\\n  function toInitializationActions(bytes memory input) internal pure returns (ShifterBorrowProxyLib.InitializationAction[] memory action) {\\n    (action) = abi.decode(input, (ShifterBorrowProxyLib.InitializationAction[]));\\n  }\\n  function encodeInitializationActions(ShifterBorrowProxyLib.InitializationAction[] memory input) internal pure returns (bytes memory result) {\\n    result = abi.encode(input);\\n  }\\n  function _shrink(Context memory context) internal pure {\\n    _write(context.trace, context.trace.length - 1);\\n  }\\n  function encodeProxyCall(ProtectedExecution memory execution) internal pure returns (bytes memory retval) {\\n    retval = abi.encodeWithSelector(BorrowProxy.proxy.selector, execution.to, 0, execution.txData);\\n  }\\n  function toFlat(ProtectedExecution[][] memory execution) internal pure returns (ProtectedExecution[] memory trace) {\\n    uint256 total = 0;\\n    for (uint256 i = 0; i < execution.length; i++) {\\n      total += execution[i].length;\\n    }\\n    trace = new ProtectedExecution[](total);\\n    uint256 seen = 0;\\n    for (uint256 i = 0; i < execution.length; i++) {\\n      for (uint256 j = 0; j < execution[i].length; j++) {\\n        trace[seen] = execution[i][j];\\n      }\\n    }\\n  }\\n  function getNewContext(ShifterBorrowProxyLib.InitializationAction[] memory actions) internal pure returns (Context memory context) {\\n    ProtectedExecution[][] memory trace = new ProtectedExecution[][](actions.length);\\n    for (uint256 i = 0; i < actions.length; i++) {\\n      trace[i] = new ProtectedExecution[](1);\\n      trace[i][0].to = actions[i].to;\\n      trace[i][0].txData = actions[i].txData;\\n    }\\n    context = Context({\\n      trace: trace,\\n      preprocessorAddress: address(0)\\n    });\\n  }\\n  struct ExecutionContext {\\n    ProtectedExecution last;\\n    address preprocessorAddress;\\n  }\\n  function executeSafeView(bytes memory creationCode, uint256 index, Context memory context) internal returns (SafeViewLib.SafeViewResult memory result) {\\n    ExecutionContext memory executionContext;\\n    executionContext.preprocessorAddress = context.preprocessorAddress;\\n    if (index != 0) {\\n      ProtectedExecution[] memory lastBatch = context.trace[index];\\n      if (lastBatch.length != 0) executionContext.last = lastBatch[lastBatch.length - 1];\\n    }\\n    result = creationCode.safeView(encodeContext(executionContext));\\n  }\\n  function processActions(ShifterBorrowProxyLib.InitializationAction[] memory actions) internal returns (ProtectedExecution[] memory trace) {\\n    Context memory context = getNewContext(actions);\\n    for (uint256 i = 0; i < actions.length; i++) {\\n      ProtectedExecution[] memory execution = context.trace[i];\\n      if (execution[0].to == address(0x0)) {\\n        context.preprocessorAddress = execution[0].txData.deriveViewAddress();\\n        SafeViewLib.SafeViewResult memory safeViewResult = executeSafeView(execution[0].txData, i, context);\\n        execution[0].txData = new bytes(0x0);\\n        if (safeViewResult.success) {\\n          if (!applyExecutionResult(context.trace, i, toInitializationActions(safeViewResult.data))) break;\\n        } else {\\n          execution[0].returnData = safeViewResult.data;\\n          execution[0].success = safeViewResult.success;\\n// for debugging\\n          bytes memory data = execution[0].returnData;\\n          assembly {\\n            revert(add(data, 0x20), mload(data))\\n          }\\n// end\\n          continue;\\n        }\\n      }\\n      execution = context.trace[i];\\n      for (uint256 j = 0; j < execution.length; j++) {\\n        (bool success, bytes memory returnData) = address(this).call(encodeProxyCall(execution[j]));\\n        execution[j].success = success;\\n// for debugging\\n        if (!execution[j].success) {\\n          assembly {\\n            revert(add(0x20, returnData), mload(returnData))\\n          }\\n        }\\n// end\\n        execution[j].returnData = returnData;\\n      }\\n    }\\n    return toFlat(context.trace);\\n  }\\n}\\n\",\"keccak256\":\"0xd33735411d05231e29ecb682b11fb8612c308b90d1eabccc97951f54c8290b87\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b5061070d806100206000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c806309c5eabe146100465780639ded06df1461006f578063d4b8399214610084575b600080fd5b6100596100543660046103ed565b610099565b60405161006691906105a0565b60405180910390f35b61008261007d3660046103ed565b61021c565b005b61008c610253565b6040516100669190610573565b60606100a3610316565b6100ac83610262565b60025460208083015160408051636a5c1cc960e11b815290519495506001600160a01b03938416946102149463a9059cbb60e01b9493169263d4b839929260048082019391829003018186803b15801561010557600080fd5b505afa158015610119573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061013d91906103d1565b6040516370a0823160e01b81526001600160a01b038516906370a0823190610169903090600401610573565b60206040518083038186803b15801561018157600080fd5b505afa158015610195573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101b9919061055b565b6040516024016101ca929190610587565b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b0319909316929092179091526002546001600160a01b03169063ffffffff61027916565b949350505050565b8080602001905181019061023091906103d1565b600b80546001600160a01b0319166001600160a01b039290921691909117905550565b600b546001600160a01b031681565b61026a610316565b610273826102a8565b92915050565b60606102a16040518060400160405280856001600160a01b03168152602001848152506102c4565b9392505050565b6102b0610316565b818060200190518101906102739190610464565b604080516001808252818301909252606091816020015b6102e3610336565b8152602001906001900390816102db579050509050818160008151811061030657fe5b6020026020010181905250919050565b604051806040016040528061032961034e565b8152600060209091015290565b60408051808201909152600081526060602082015290565b604080516080810182526000808252606060208301819052928201528181019190915290565b8051610273816106b1565b600082601f83011261038f578081fd5b81516103a261039d8261065d565b610636565b91508082528360208285010111156103b957600080fd5b6103ca816020840160208601610681565b5092915050565b6000602082840312156103e2578081fd5b81516102a1816106b1565b6000602082840312156103fe578081fd5b813567ffffffffffffffff811115610414578182fd5b80830184601f820112610425578283fd5b8035915061043561039d8361065d565b828152856020848401011115610449578384fd5b82602083016020830137918201602001929092529392505050565b600060208284031215610475578081fd5b815167ffffffffffffffff8082111561048c578283fd5b8184016040818703121561049e578384fd5b6104a86040610636565b92508051828111156104b8578485fd5b808201608081890312156104ca578586fd5b6104d46080610636565b915080516104e1816106b1565b82526020810151848111156104f4578687fd5b6105008982840161037f565b6020840152506040810151610514816106c9565b604083015260608101518481111561052a578687fd5b6105368982840161037f565b60608401525050835261054c8660208301610374565b60208401525090949350505050565b60006020828403121561056c578081fd5b5051919050565b6001600160a01b0391909116815260200190565b6001600160a01b03929092168252602082015260400190565b60208082528251828201819052600091906040908185019080840286018301878501865b8381101561062857888303603f19018552815180516001600160a01b03168452870151878401879052805187850181905290606061060783828801848d01610681565b96890196601f92909201601f191694909401019250908601906001016105c4565b509098975050505050505050565b60405181810167ffffffffffffffff8111828210171561065557600080fd5b604052919050565b600067ffffffffffffffff821115610673578081fd5b50601f01601f191660200190565b60005b8381101561069c578181015183820152602001610684565b838111156106ab576000848401525b50505050565b6001600160a01b03811681146106c657600080fd5b50565b80151581146106c657600080fdfea26469706673582212200b6f15d31ec9f620657345c0e2fed666dc0177e08fb1ea817c3f00a2ab0bba4164736f6c634300060a0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100415760003560e01c806309c5eabe146100465780639ded06df1461006f578063d4b8399214610084575b600080fd5b6100596100543660046103ed565b610099565b60405161006691906105a0565b60405180910390f35b61008261007d3660046103ed565b61021c565b005b61008c610253565b6040516100669190610573565b60606100a3610316565b6100ac83610262565b60025460208083015160408051636a5c1cc960e11b815290519495506001600160a01b03938416946102149463a9059cbb60e01b9493169263d4b839929260048082019391829003018186803b15801561010557600080fd5b505afa158015610119573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061013d91906103d1565b6040516370a0823160e01b81526001600160a01b038516906370a0823190610169903090600401610573565b60206040518083038186803b15801561018157600080fd5b505afa158015610195573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101b9919061055b565b6040516024016101ca929190610587565b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b0319909316929092179091526002546001600160a01b03169063ffffffff61027916565b949350505050565b8080602001905181019061023091906103d1565b600b80546001600160a01b0319166001600160a01b039290921691909117905550565b600b546001600160a01b031681565b61026a610316565b610273826102a8565b92915050565b60606102a16040518060400160405280856001600160a01b03168152602001848152506102c4565b9392505050565b6102b0610316565b818060200190518101906102739190610464565b604080516001808252818301909252606091816020015b6102e3610336565b8152602001906001900390816102db579050509050818160008151811061030657fe5b6020026020010181905250919050565b604051806040016040528061032961034e565b8152600060209091015290565b60408051808201909152600081526060602082015290565b604080516080810182526000808252606060208301819052928201528181019190915290565b8051610273816106b1565b600082601f83011261038f578081fd5b81516103a261039d8261065d565b610636565b91508082528360208285010111156103b957600080fd5b6103ca816020840160208601610681565b5092915050565b6000602082840312156103e2578081fd5b81516102a1816106b1565b6000602082840312156103fe578081fd5b813567ffffffffffffffff811115610414578182fd5b80830184601f820112610425578283fd5b8035915061043561039d8361065d565b828152856020848401011115610449578384fd5b82602083016020830137918201602001929092529392505050565b600060208284031215610475578081fd5b815167ffffffffffffffff8082111561048c578283fd5b8184016040818703121561049e578384fd5b6104a86040610636565b92508051828111156104b8578485fd5b808201608081890312156104ca578586fd5b6104d46080610636565b915080516104e1816106b1565b82526020810151848111156104f4578687fd5b6105008982840161037f565b6020840152506040810151610514816106c9565b604083015260608101518481111561052a578687fd5b6105368982840161037f565b60608401525050835261054c8660208301610374565b60208401525090949350505050565b60006020828403121561056c578081fd5b5051919050565b6001600160a01b0391909116815260200190565b6001600160a01b03929092168252602082015260400190565b60208082528251828201819052600091906040908185019080840286018301878501865b8381101561062857888303603f19018552815180516001600160a01b03168452870151878401879052805187850181905290606061060783828801848d01610681565b96890196601f92909201601f191694909401019250908601906001016105c4565b509098975050505050505050565b60405181810167ffffffffffffffff8111828210171561065557600080fd5b604052919050565b600067ffffffffffffffff821115610673578081fd5b50601f01601f191660200190565b60005b8381101561069c578181015183820152602001610684565b838111156106ab576000848401525b50505050565b6001600160a01b03811681146106c657600080fd5b50565b80151581146106c657600080fdfea26469706673582212200b6f15d31ec9f620657345c0e2fed666dc0177e08fb1ea817c3f00a2ab0bba4164736f6c634300060a0033",
  "libraries": {},
  "devdoc": {
    "methods": {}
  },
  "userdoc": {
    "methods": {}
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 11165,
        "contract": "contracts/preprocessors/TransferAll.sol:TransferAll",
        "label": "isolate",
        "offset": 0,
        "slot": "0",
        "type": "t_struct(ProxyIsolate)2329_storage"
      },
      {
        "astId": 11167,
        "contract": "contracts/preprocessors/TransferAll.sol:TransferAll",
        "label": "target",
        "offset": 0,
        "slot": "11",
        "type": "t_address"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_address_payable": {
        "encoding": "inplace",
        "label": "address payable",
        "numberOfBytes": "20"
      },
      "t_array(t_address)dyn_storage": {
        "base": "t_address",
        "encoding": "dynamic_array",
        "label": "address[]",
        "numberOfBytes": "32"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_struct(AddressSet)11747_storage": {
        "encoding": "inplace",
        "label": "struct AddressSetLib.AddressSet",
        "members": [
          {
            "astId": 11743,
            "contract": "contracts/preprocessors/TransferAll.sol:TransferAll",
            "label": "uniq",
            "offset": 0,
            "slot": "0",
            "type": "t_mapping(t_address,t_bool)"
          },
          {
            "astId": 11746,
            "contract": "contracts/preprocessors/TransferAll.sol:TransferAll",
            "label": "set",
            "offset": 0,
            "slot": "1",
            "type": "t_array(t_address)dyn_storage"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(ProxyIsolate)2329_storage": {
        "encoding": "inplace",
        "label": "struct BorrowProxyLib.ProxyIsolate",
        "members": [
          {
            "astId": 2308,
            "contract": "contracts/preprocessors/TransferAll.sol:TransferAll",
            "label": "masterAddress",
            "offset": 0,
            "slot": "0",
            "type": "t_address_payable"
          },
          {
            "astId": 2310,
            "contract": "contracts/preprocessors/TransferAll.sol:TransferAll",
            "label": "unbound",
            "offset": 20,
            "slot": "0",
            "type": "t_bool"
          },
          {
            "astId": 2312,
            "contract": "contracts/preprocessors/TransferAll.sol:TransferAll",
            "label": "owner",
            "offset": 0,
            "slot": "1",
            "type": "t_address"
          },
          {
            "astId": 2314,
            "contract": "contracts/preprocessors/TransferAll.sol:TransferAll",
            "label": "token",
            "offset": 0,
            "slot": "2",
            "type": "t_address"
          },
          {
            "astId": 2316,
            "contract": "contracts/preprocessors/TransferAll.sol:TransferAll",
            "label": "actualizedShift",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          },
          {
            "astId": 2318,
            "contract": "contracts/preprocessors/TransferAll.sol:TransferAll",
            "label": "liquidationIndex",
            "offset": 0,
            "slot": "4",
            "type": "t_uint256"
          },
          {
            "astId": 2320,
            "contract": "contracts/preprocessors/TransferAll.sol:TransferAll",
            "label": "repaymentIndex",
            "offset": 0,
            "slot": "5",
            "type": "t_uint256"
          },
          {
            "astId": 2322,
            "contract": "contracts/preprocessors/TransferAll.sol:TransferAll",
            "label": "isRepaying",
            "offset": 0,
            "slot": "6",
            "type": "t_bool"
          },
          {
            "astId": 2324,
            "contract": "contracts/preprocessors/TransferAll.sol:TransferAll",
            "label": "isLiquidating",
            "offset": 1,
            "slot": "6",
            "type": "t_bool"
          },
          {
            "astId": 2326,
            "contract": "contracts/preprocessors/TransferAll.sol:TransferAll",
            "label": "liquidationSet",
            "offset": 0,
            "slot": "7",
            "type": "t_struct(AddressSet)11747_storage"
          },
          {
            "astId": 2328,
            "contract": "contracts/preprocessors/TransferAll.sol:TransferAll",
            "label": "repaymentSet",
            "offset": 0,
            "slot": "9",
            "type": "t_struct(AddressSet)11747_storage"
          }
        ],
        "numberOfBytes": "352"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  },
  "gasEstimates": {
    "creation": {
      "codeDepositCost": "361000",
      "executionCost": "399",
      "totalCost": "361399"
    },
    "external": {
      "execute(bytes)": "infinite",
      "setup(bytes)": "infinite",
      "target()": "1092"
    }
  }
}