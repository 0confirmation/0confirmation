{
  "address": "0x4a372ab9085a4bc7328712532D475fc81312f7E0",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "erc20Module",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "getExternalIsolateHandler",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "liquidityMinimum",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "erc20Module",
              "type": "address"
            }
          ],
          "internalType": "struct UniswapV2AdapterLib.Isolate",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address payable",
              "name": "moduleAddress",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "liquidationSubmodule",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "repaymentSubmodule",
              "type": "address"
            },
            {
              "internalType": "address payable",
              "name": "token",
              "type": "address"
            },
            {
              "internalType": "address payable",
              "name": "txOrigin",
              "type": "address"
            },
            {
              "internalType": "address payable",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "value",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "callData",
              "type": "bytes"
            }
          ],
          "internalType": "struct ModuleLib.AssetSubmodulePayload",
          "name": "payload",
          "type": "tuple"
        }
      ],
      "name": "handle",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    }
  ],
  "transactionHash": "0x493281bea20b404be46254ed69b4e3d74463fb9585e3e298673d65c1d83f1f1d",
  "receipt": {
    "to": null,
    "from": "0x5D557f7a73C7494be0dcEB5DBF8C5c209811fdA6",
    "contractAddress": "0x4a372ab9085a4bc7328712532D475fc81312f7E0",
    "transactionIndex": 59,
    "gasUsed": "1660995",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x3aaab42b4a8ec9978a71af40cdb64d4111fa139c57e02711cb7c3bba8cd9b3f3",
    "transactionHash": "0x493281bea20b404be46254ed69b4e3d74463fb9585e3e298673d65c1d83f1f1d",
    "logs": [],
    "blockNumber": 11252970,
    "cumulativeGasUsed": "7379327",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xA81Da4FFb2fa1771B6C9f546A565285544aC15B3"
  ],
  "solcInputHash": "0x4ad71a06889361ed9ee42fc3cc3f9d59e654b4607e98c6d6bba47a63180890ff",
  "metadata": "{\"compiler\":{\"version\":\"0.6.10+commit.00c0fcaf\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"erc20Module\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"getExternalIsolateHandler\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"liquidityMinimum\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"erc20Module\",\"type\":\"address\"}],\"internalType\":\"struct UniswapV2AdapterLib.Isolate\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address payable\",\"name\":\"moduleAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidationSubmodule\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"repaymentSubmodule\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"txOrigin\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"internalType\":\"struct ModuleLib.AssetSubmodulePayload\",\"name\":\"payload\",\"type\":\"tuple\"}],\"name\":\"handle\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"methods\":{}},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"contracts/adapters/assets/uniswap-v2/UniswapV2Adapter.sol\":\"UniswapV2Adapter\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/GSN/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xdb26cbf4d028490f49831a7865c2fe1b28db44b535ca8d343785a3b768aae183\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\",\"keccak256\":\"0x4bd6402ca6b3419008c2b482aff54e66836e8cb4eba2680e42ac5884ae6424fc\",\"license\":\"MIT\"},\"@openzeppelin/contracts/cryptography/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        // Check the signature length\\n        if (signature.length != 65) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        }\\n\\n        // Divide the signature in r, s and v variables\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // ecrecover takes the signature parameters, and the only way to get them\\n        // currently is to use assembly.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := byte(0, mload(add(signature, 0x60)))\\n        }\\n\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (281): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (282): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n\\n        if (v != 27 && v != 28) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        require(signer != address(0), \\\"ECDSA: invalid signature\\\");\\n\\n        return signer;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * replicates the behavior of the\\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\\n     * JSON-RPC method.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n}\\n\",\"keccak256\":\"0x1efcb1ccef6b3bce65467c4b704cec8d0582e35ff48352269ba8cda4b54ae3da\",\"license\":\"MIT\"},\"@openzeppelin/contracts/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\",\"keccak256\":\"0x6c234834003dfb86e2c23d12dfdde7cc01e78013d71b52162cb308b4873562cb\",\"license\":\"MIT\"},\"@openzeppelin/contracts/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\",\"keccak256\":\"0x9a9cf02622cd7a64261b10534fc3260449da25c98c9e96d1b4ae8110a20e5806\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name, string memory symbol) public {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20};\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\",\"keccak256\":\"0x91e0bd6a6762d2a1700dab0849de8422611355100576c4beef1e80d82a4104a0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\\n * tokens and those that they have an allowance for, in a way that can be\\n * recognized off-chain (via event analysis).\\n */\\nabstract contract ERC20Burnable is Context, ERC20 {\\n    /**\\n     * @dev Destroys `amount` tokens from the caller.\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(uint256 amount) public virtual {\\n        _burn(_msgSender(), amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\\n     * allowance.\\n     *\\n     * See {ERC20-_burn} and {ERC20-allowance}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have allowance for ``accounts``'s tokens of at least\\n     * `amount`.\\n     */\\n    function burnFrom(address account, uint256 amount) public virtual {\\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \\\"ERC20: burn amount exceeds allowance\\\");\\n\\n        _approve(account, _msgSender(), decreasedAllowance);\\n        _burn(account, amount);\\n    }\\n}\\n\",\"keccak256\":\"0x657b0d90be17331364211d74359df2a734fac864f6e88c80de7626fa33090ffb\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x5c26b39d26f7ed489e555d955dcd3e01872972e71fdd1528e93ec164e4f23385\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.2;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies in extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        return _functionCallWithValue(target, data, value, errorMessage);\\n    }\\n\\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf5fa8cbdffa5ef8be49b246b5628facc30b71707e78a45d80d93b64eff3fe390\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Create2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\\n * `CREATE2` can be used to compute in advance the address where a smart\\n * contract will be deployed, which allows for interesting new mechanisms known\\n * as 'counterfactual interactions'.\\n *\\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\\n * information.\\n */\\nlibrary Create2 {\\n    /**\\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\\n     * will be deployed can be known in advance via {computeAddress}.\\n     *\\n     * The bytecode for a contract can be obtained from Solidity with\\n     * `type(contractName).creationCode`.\\n     *\\n     * Requirements:\\n     *\\n     * - `bytecode` must not be empty.\\n     * - `salt` must have not been used for `bytecode` already.\\n     * - the factory must have a balance of at least `amount`.\\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\\n     */\\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address) {\\n        address addr;\\n        require(address(this).balance >= amount, \\\"Create2: insufficient balance\\\");\\n        require(bytecode.length != 0, \\\"Create2: bytecode length is zero\\\");\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\\n        }\\n        require(addr != address(0), \\\"Create2: Failed on deploy\\\");\\n        return addr;\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\\n     * `bytecodeHash` or `salt` will result in a new destination address.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\\n        return computeAddress(salt, bytecodeHash, address(this));\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address) {\\n        bytes32 _data = keccak256(\\n            abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash)\\n        );\\n        return address(uint256(_data));\\n    }\\n}\\n\",\"keccak256\":\"0x16926b3c19504ea52f73abe41dfa9c1ef9c328d6088b82162d475caecaa47a6d\",\"license\":\"MIT\"},\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\":{\"content\":\"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\",\"keccak256\":\"0x8a3c5c449d4b7cd76513ed6995f4b86e4a86f222c770f8442f5fc128ce29b4d2\"},\"contracts/BorrowProxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma experimental ABIEncoderV2;\\npragma solidity ^0.6.0;\\n\\nimport { BorrowProxyLib } from \\\"./BorrowProxyLib.sol\\\";\\nimport { RevertCaptureLib } from \\\"./utils/RevertCaptureLib.sol\\\";\\nimport { SliceLib } from \\\"./utils/SliceLib.sol\\\";\\nimport { IShifter } from \\\"./interfaces/IShifter.sol\\\";\\nimport { IBorrowProxyController } from \\\"./interfaces/IBorrowProxyController.sol\\\";\\nimport { AddressSetLib } from \\\"./utils/AddressSetLib.sol\\\";\\nimport { ModuleLib } from \\\"./adapters/lib/ModuleLib.sol\\\";\\n\\ncontract BorrowProxy {\\n  using SliceLib for *;\\n  using BorrowProxyLib for *;\\n  using AddressSetLib for *;\\n  BorrowProxyLib.ProxyIsolate isolate;\\n  modifier onlyOwnerOrPool {\\n   require(msg.sender == isolate.owner || msg.sender == isolate.masterAddress || msg.sender == address(this), \\\"borrow proxy can only be used by borrower\\\");\\n    _;\\n  }\\n  function setup(address owner, address token, bool unbound) public returns (bool) {\\n    require(isolate.owner == address(0x0), \\\"can't initialize twice\\\");\\n    isolate.masterAddress = msg.sender;\\n    isolate.owner = owner;\\n    isolate.unbound = unbound;\\n    isolate.token = token;\\n    return true;\\n  }\\n  function validateProxyRecord(bytes memory record) internal returns (bool) {\\n    return IBorrowProxyController(isolate.masterAddress).validateProxyRecordHandler(record);\\n  }\\n  function proxy(address to, uint256 value, bytes memory payload) public onlyOwnerOrPool {\\n    require(to != isolate.masterAddress, \\\"can't target the ShifterPool\\\");\\n    bytes4 sig = bytes4(uint32(uint256(payload.toSlice(0, 4).asWord())));\\n    BorrowProxyLib.ModuleExecution memory module = isolate.fetchModule(to, sig);\\n    module.token = isolate.token;\\n    if (isolate.unbound && !module.encapsulated.isPrecompiled) {\\n      (bool success, bytes memory retval) = to.call{\\n        value: value\\n      }(payload);\\n      if (!success) revert(RevertCaptureLib.decodeError(retval));\\n      ModuleLib.bubbleResult(success, retval);\\n      return;\\n    }\\n    require(module.encapsulated.isDefined(), \\\"function handler not registered\\\");\\n    (bool success, bytes memory retval) = module.delegate(payload, value);\\n    if (!success) revert(RevertCaptureLib.decodeError(retval));\\n    if (module.encapsulated.liquidationSubmodule != address(0x0)) isolate.liquidationSet.insert(module.encapsulated.liquidationSubmodule);\\n    if (module.encapsulated.repaymentSubmodule != address(0x0)) {\\n      isolate.repaymentSet.insert(module.encapsulated.repaymentSubmodule);\\n    }\\n    ModuleLib.bubbleResult(success, retval);\\n  }\\n  receive() external payable virtual {\\n    // just receive ether, do nothing\\n  } \\n  fallback() external payable virtual {}\\n}\\n\",\"keccak256\":\"0x03d42cac11c2991b721b81bde53cf60542339ee279c1d420a1e5fb1254dadba9\",\"license\":\"MIT\"},\"contracts/BorrowProxyLib.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { Create2 } from \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\nimport { IModuleRegistryProvider } from \\\"./interfaces/IModuleRegistryProvider.sol\\\";\\nimport { AddressSetLib } from \\\"./utils/AddressSetLib.sol\\\";\\nimport { ExtLib } from \\\"./utils/ExtLib.sol\\\";\\nimport { RevertCaptureLib } from \\\"./utils/RevertCaptureLib.sol\\\";\\nimport { SandboxLib } from \\\"./utils/sandbox/SandboxLib.sol\\\";\\nimport { ModuleLib } from \\\"./adapters/lib/ModuleLib.sol\\\";\\n\\nlibrary BorrowProxyLib {\\n  using ModuleLib for *;\\n  struct ProxyIsolate {\\n    address payable masterAddress;\\n    bool unbound;\\n    address owner;\\n    address token;\\n    uint256 actualizedShift;\\n    uint256 liquidationIndex;\\n    uint256 repaymentIndex;\\n    bool isRepaying;\\n    bool isLiquidating;\\n    AddressSetLib.AddressSet liquidationSet;\\n    AddressSetLib.AddressSet repaymentSet;\\n  }\\n  struct ControllerIsolate {\\n    mapping (address => bytes32) proxyInitializerRecord;\\n    mapping (address => address) ownerByProxy;\\n    mapping (address => address) tokenByProxy;\\n    mapping (address => bool) isKeeper;\\n  }\\n  struct Module {\\n    bool isPrecompiled;\\n    address assetSubmodule;\\n    address liquidationSubmodule;\\n    address repaymentSubmodule;\\n  }\\n  struct ModuleDetails {\\n    ModuleRegistrationType moduleType;\\n    address target;\\n    bytes4[] sigs;\\n  }\\n  struct ModuleRegistration {\\n    ModuleRegistrationType moduleType;\\n    address target;\\n    bytes4[] sigs;\\n    Module module;\\n  }\\n  enum ModuleRegistrationType {\\n    UNINITIALIZED,\\n    BY_CODEHASH,\\n    BY_ADDRESS\\n  }\\n  struct ModuleExecution {\\n    address to;\\n    address token;\\n    Module encapsulated;\\n  }\\n  function registryRegisterModule(ModuleRegistry storage registry, ModuleRegistration memory registration) internal {\\n    if (registration.moduleType == ModuleRegistrationType.BY_CODEHASH) for (uint256 i = 0; i < registration.sigs.length; i++) {\\n      registerModuleByCodeHash(registry, registration.target, registration.sigs[i], registration.module);\\n    } else if (registration.moduleType == ModuleRegistrationType.BY_ADDRESS) for (uint256 i = 0; i < registration.sigs.length; i++) {\\n      registerModuleByAddress(registry, registration.target, registration.sigs[i], registration.module);\\n    }\\n  }\\n  function encodeLiquidate(address liquidationSubmodule) internal pure returns (bytes memory retval) {\\n    retval = abi.encodeWithSignature(\\\"liquidate(address)\\\", liquidationSubmodule);\\n  }\\n  function decodeBool(bytes memory input) internal pure returns (bool retval) {\\n    (retval) = abi.decode(input, (bool));\\n  }\\n  function delegateLiquidate(address liquidationSubmodule) internal returns (bool) {\\n    (bool success, bytes memory retval) = liquidationSubmodule.delegatecall(encodeLiquidate(liquidationSubmodule));\\n    if (!success) revert(RevertCaptureLib.decodeError(retval));\\n    return decodeBool(retval);\\n  }\\n  function encodeRepay(address repaymentSubmodule) internal pure returns (bytes memory retval) {\\n    retval = abi.encodeWithSignature(\\\"repay(address)\\\", repaymentSubmodule);\\n  }\\n  function delegateRepay(address repaymentSubmodule) internal returns (bool) {\\n    (bool success, bytes memory retval) = repaymentSubmodule.delegatecall(encodeRepay(repaymentSubmodule));\\n    if (!success) revert(RevertCaptureLib.decodeError(retval));\\n    return decodeBool(retval);\\n  }\\n  function encodeNotify(address liquidationSubmodule, bytes memory payload) internal pure returns (bytes memory retval) {\\n    retval = abi.encodeWithSignature(\\\"notify(address,bytes)\\\", liquidationSubmodule, payload);\\n  }\\n  function delegateNotify(address liquidationSubmodule, bytes memory payload) internal returns (bool) {\\n    (bool success,) = liquidationSubmodule.delegatecall(encodeNotify(liquidationSubmodule, payload));\\n    return success;\\n  }\\n  function delegate(ModuleExecution memory module, bytes memory payload, uint256 value) internal returns (bool, bytes memory) {\\n    (bool success, bytes memory retval) = module.encapsulated.assetSubmodule.delegatecall{ gas: gasleft() }(ModuleLib.AssetSubmodulePayload({\\n      moduleAddress: address(uint160(module.encapsulated.assetSubmodule)),\\n      liquidationSubmodule: module.encapsulated.liquidationSubmodule,\\n      repaymentSubmodule: module.encapsulated.repaymentSubmodule,\\n      token: address(uint160(module.token)),\\n      txOrigin: tx.origin,\\n      to: address(uint160(module.to)),\\n      value: value,\\n      callData: payload\\n    }).encodeWithSelector());\\n    return (success, retval);\\n  }\\n  function isDefined(Module memory module) internal pure returns (bool) {\\n    return module.assetSubmodule != address(0x0);\\n  }\\n  function isInitialized(ControllerIsolate storage isolate, address proxyAddress) internal view returns (bool) {\\n    return isolate.proxyInitializerRecord[proxyAddress] != bytes32(uint256(0x0));\\n  }\\n  struct ModuleRegistry {\\n    mapping (bytes32 => Module) modules;\\n  }\\n  function isDisbursing(ProxyIsolate storage isolate) internal view returns (bool) {\\n    return isolate.isLiquidating && isolate.liquidationIndex != isolate.liquidationSet.set.length;\\n  }\\n  event BorrowProxyMade(address indexed user, address indexed proxyAddress, bytes record);\\n  function emitBorrowProxyMade(address user, address proxyAddress, bytes memory record) internal {\\n    emit BorrowProxyMade(user, proxyAddress, record);\\n  }\\n  function computeModuleKeyPreimage(address to, bytes4 signature) internal pure returns (bytes memory result) {\\n    result = abi.encodePacked(to, signature);\\n  }\\n  function computeModuleKey(address to, bytes4 signature) internal pure returns (bytes32) {\\n    return keccak256(computeModuleKeyPreimage(to, signature));\\n  }\\n  function computeCodeResolverKeyPreimage(bytes32 codehash, bytes4 signature) internal pure returns (bytes memory result) {\\n    result = abi.encodePacked(codehash, signature);\\n  }\\n  function computeCodeResolverKey(address to, bytes4 signature) internal view returns (bytes32) {\\n    bytes32 exthash = ExtLib.getExtCodeHash(to);\\n    return keccak256(computeCodeResolverKeyPreimage(exthash, signature));\\n  }\\n  function resolveModule(ModuleRegistry storage registry, address to, bytes4 sig) internal view returns (Module memory) {\\n    Module memory module = registry.modules[computeCodeResolverKey(to, sig)];\\n    if (!isDefined(module)) module = registry.modules[computeModuleKey(to, sig)];\\n    return module;\\n  }\\n  function getModuleExecution(ModuleRegistry storage registry, address to, bytes4 signature) internal view returns (ModuleExecution memory) {\\n    Module memory encapsulated = resolveModule(registry, to, signature);\\n    return ModuleExecution({\\n      encapsulated: encapsulated,\\n      token: address(0x0), // fill in in the proxy call\\n      to: to\\n    });\\n  }\\n  function validateProxyRecord(ControllerIsolate storage isolate, address proxyAddress, bytes memory data) internal view returns (bool) {\\n    return isolate.proxyInitializerRecord[proxyAddress] == keccak256(data);\\n  }\\n  function mapProxyRecord(ControllerIsolate storage isolate, address proxyAddress, bytes memory data) internal {\\n    isolate.proxyInitializerRecord[proxyAddress] = keccak256(data);\\n  }\\n  function setProxyOwner(ControllerIsolate storage isolate, address proxyAddress, address identity) internal {\\n    isolate.ownerByProxy[proxyAddress] = identity;\\n  }\\n  function setProxyToken(ControllerIsolate storage isolate, address proxyAddress, address token) internal {\\n    isolate.tokenByProxy[proxyAddress] = token;\\n  }\\n  function getProxyToken(ControllerIsolate storage isolate, address proxyAddress) internal view returns (address) {\\n    return isolate.tokenByProxy[proxyAddress];\\n  }\\n  function getProxyOwner(ControllerIsolate storage isolate, address proxyAddress) internal view returns (address) {\\n    return isolate.ownerByProxy[proxyAddress];\\n  }\\n  function registerModuleByAddress(ModuleRegistry storage registry, address to, bytes4 signature, Module memory module) internal {\\n    registry.modules[computeModuleKey(to, signature)] = module;\\n  }\\n  function registerModuleByCodeHash(ModuleRegistry storage registry, address to, bytes4 signature, Module memory module) internal {\\n    registry.modules[computeCodeResolverKey(to, signature)] = module;\\n  }\\n  function fetchModule(ProxyIsolate storage isolate, address to, bytes4 signature) internal returns (ModuleExecution memory) {\\n    return ModuleExecution({\\n      encapsulated: IModuleRegistryProvider(isolate.masterAddress).fetchModuleHandler(to, signature),\\n      token: isolate.token,\\n      to: to\\n    });\\n  }\\n}\\n\",\"keccak256\":\"0xec2de85244c570599f4c128c83ffdbe413b6f44c81cd59eb0f244b6686e4700b\",\"license\":\"MIT\"},\"contracts/FactoryLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { Create2 } from \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\n\\nlibrary FactoryLib {\\n  function computeCreationCode(address target) internal view returns (bytes memory clone) {\\n    clone = computeCreationCode(address(this), target);\\n  }\\n  function computeCreationCode(address deployer, address target) internal pure returns (bytes memory clone) {\\n      bytes memory consData = abi.encodeWithSignature(\\\"cloneConstructor(bytes)\\\", new bytes(0));\\n      clone = new bytes(99 + consData.length);\\n      assembly {\\n        mstore(add(clone, 0x20),\\n           0x3d3d606380380380913d393d73bebebebebebebebebebebebebebebebebebebe)\\n        mstore(add(clone, 0x2d),\\n           mul(deployer, 0x01000000000000000000000000))\\n        mstore(add(clone, 0x41),\\n           0x5af4602a57600080fd5b602d8060366000396000f3363d3d373d3d3d363d73be)\\n           mstore(add(clone, 0x60),\\n           mul(target, 0x01000000000000000000000000))\\n        mstore(add(clone, 116),\\n           0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n      }\\n      for (uint256 i = 0; i < consData.length; i++) {\\n        clone[i + 99] = consData[i];\\n      }\\n  }\\n  function deriveInstanceAddress(address target, bytes32 salt) internal view returns (address) {\\n    return Create2.computeAddress(salt, keccak256(computeCreationCode(target)));\\n  }\\n  function deriveInstanceAddress(address from, address target, bytes32 salt) internal pure returns (address) {\\n     return Create2.computeAddress(salt, keccak256(computeCreationCode(from, target)), from);\\n  }\\n  function create2Clone(address target, uint saltNonce) internal returns (address result) {\\n    bytes memory clone = computeCreationCode(target);\\n    bytes32 salt = bytes32(saltNonce);\\n      \\n    assembly {\\n      let len := mload(clone)\\n      let data := add(clone, 0x20)\\n      result := create2(0, data, len, salt)\\n    }\\n      \\n    require(result != address(0), \\\"create2 failed\\\");\\n  }\\n}\\n\",\"keccak256\":\"0x09418dc79042d919578b3bff5fe513e9dfcee33d26cd0548076b2ccd3287f6ca\",\"license\":\"MIT\"},\"contracts/LiquidityToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma experimental ABIEncoderV2;\\npragma solidity ^0.6.0;\\n\\nimport { ERC20 } from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { ERC20Burnable } from \\\"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\\\";\\nimport { TokenUtils } from \\\"./utils/TokenUtils.sol\\\";\\nimport { IUniswapV2Router01 } from \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\\\";\\nimport { SafeMath } from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\ncontract LiquidityToken is ERC20, ERC20Burnable {\\n  using TokenUtils for *;\\n  address payable public pool;\\n  address public asset;\\n  address public router;\\n  address public weth;\\n  uint256 public offset;\\n  mapping (address => uint256) public outstandingLoans;\\n  constructor(address _weth, address _router, address payable shifterPool, address underlyingAsset, string memory name, string memory symbol, uint8 decimals) ERC20(name, symbol) public {\\n    weth = _weth;\\n    router = _router;\\n    pool = shifterPool;\\n    asset = underlyingAsset;\\n    require(weth.approveForMaxIfNeeded(router) && asset.approveForMaxIfNeeded(router), \\\"failed to approve router for asset\\\");\\n    _setupDecimals(decimals);\\n  }\\n  modifier onlyPool {\\n    require(msg.sender == pool, \\\"must be called by pool manager\\\");\\n    _;\\n  }\\n  function loan(address proxy, uint256 amount, uint256 getGas) public onlyPool returns (bool) {\\n    offset += amount;\\n    outstandingLoans[proxy] = amount;\\n    address[] memory path = new address[](2);\\n    path[0] = asset;\\n    path[1] = weth;\\n    uint256[] memory amounts = IUniswapV2Router01(router).swapTokensForExactETH(getGas, amount, path, pool, block.timestamp + 1);\\n    require(asset.sendToken(proxy, amount - amounts[0]), \\\"loan transfer failed\\\");\\n    return true;\\n  }\\n  function resolveLoan(address proxy) public onlyPool returns (bool) {\\n    offset -= outstandingLoans[proxy];\\n    outstandingLoans[proxy] = 0;\\n    return true;\\n  }\\n  function getReserve() internal view returns (uint256) {\\n    return offset + IERC20(asset).balanceOf(address(this));\\n  }\\n  function addLiquidity(uint256 value) public returns (uint256) {\\n    uint256 totalLiquidity = totalSupply();\\n    uint256 reserve = getReserve();\\n    uint256 totalMinted = value * (totalLiquidity == 0 ? 1 : totalLiquidity) / (reserve + 1);\\n    require(asset.transferTokenFrom(msg.sender, address(this), value), \\\"transfer token failed\\\");\\n    _mint(msg.sender, totalMinted);\\n    return totalMinted;\\n  }\\n  function removeLiquidity(uint256 value) public returns (uint256) {\\n    uint256 totalLiquidity = totalSupply();\\n    uint256 reserve = getReserve();\\n    uint256 totalReturned = value * (reserve + 1) / (totalLiquidity == 0 ? 1 : totalLiquidity);\\n    _burn(msg.sender, value);\\n    require(asset.sendToken(msg.sender, totalReturned), \\\"failed to send back token\\\");\\n  }\\n}\\n\",\"keccak256\":\"0x0d1bf9a81b51f72664121de63da4b3982394a2f6d0e27be32aa7f50659bd2202\",\"license\":\"MIT\"},\"contracts/NullCloneConstructor.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\ncontract NullCloneConstructor {\\n  function cloneConstructor(bytes memory consData) public {\\n    // do nothing\\n  }\\n}\\n\",\"keccak256\":\"0xd2f5fc0c88b5e8e60108ec09b25af5022d988661e2ef89f6dbecaafd34c38bad\",\"license\":\"MIT\"},\"contracts/ShifterBorrowProxy.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { TokenUtils } from \\\"./utils/TokenUtils.sol\\\";\\nimport { LiquidityToken } from \\\"./LiquidityToken.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { SafeViewExecutor } from \\\"./utils/sandbox/SafeViewExecutor.sol\\\";\\nimport { SandboxLib } from \\\"./utils/sandbox/SandboxLib.sol\\\";\\nimport { StringLib } from \\\"./utils/StringLib.sol\\\";\\nimport { NullCloneConstructor } from \\\"./NullCloneConstructor.sol\\\";\\nimport { BorrowProxy } from \\\"./BorrowProxy.sol\\\";\\nimport { ShifterBorrowProxyLib } from \\\"./ShifterBorrowProxyLib.sol\\\";\\nimport { ShifterPool } from \\\"./ShifterPool.sol\\\";\\nimport { IShifter } from \\\"./interfaces/IShifter.sol\\\";\\nimport { Math } from \\\"@openzeppelin/contracts/math/Math.sol\\\";\\n\\ncontract ShifterBorrowProxy is BorrowProxy, SafeViewExecutor, NullCloneConstructor {\\n  using ShifterBorrowProxyLib for *;\\n  using StringLib for *;\\n  using SandboxLib for *;\\n  using TokenUtils for *;\\n  uint256 constant MINIMUM_GAS_CONTINUE = 5e5;\\n  function getShifter(address token) internal view returns (IShifter shifter) {\\n    shifter = ShifterPool(isolate.masterAddress).getShifterHandler(token);\\n  }\\n  function mint(ShifterBorrowProxyLib.TriggerParcel memory parcel) internal returns (uint256 amount) {\\n    amount = getShifter(parcel.record.request.token).mint(parcel.shiftParameters.pHash, parcel.shiftParameters.amount, parcel.computeNHash(), parcel.shiftParameters.darknodeSignature);\\n  }\\n  function _getGasReserved() internal view returns (uint256 result) {\\n    result = ShifterPool(isolate.masterAddress).getGasReserved(address(this));\\n  }\\n  function _payoutCallbackGas(address payable borrower, uint256 amount, uint256 originAmount) internal {\\n    if (amount != 0) ShifterPool(isolate.masterAddress).payoutCallbackGas(borrower, amount - originAmount, originAmount);\\n  }\\n  function repayLoan(bytes memory data) public returns (bool) {\\n    uint256 startGas = gasleft();\\n    (bool success, ShifterBorrowProxyLib.ProxyRecord memory record, address payable pool, uint256 repayAmount) = _repayLoan(data);\\n    if (maybeRelayResolveLoan(success, record, pool, repayAmount)) {\\n      ShifterBorrowProxyLib.emitShifterBorrowProxyRepaid(record.request.borrower, record);\\n      uint256 amount = _getGasReserved();\\n      uint256 originAmount = Math.min((gasleft() - startGas + 20000)*tx.gasprice, amount); // another estimate\\n      _payoutCallbackGas(record.request.borrower, amount, originAmount);\\n      return true;\\n    } else return false;\\n  }\\n  function _repayLoan(bytes memory data) internal returns (bool success, ShifterBorrowProxyLib.ProxyRecord memory record, address payable pool, uint256 repayAmount) {\\n    (ShifterBorrowProxyLib.TriggerParcel memory parcel) = data.decodeTriggerParcel();\\n    record = parcel.record;\\n    parcel.record.request.actions = new ShifterBorrowProxyLib.InitializationAction[](0);\\n    require(validateProxyRecord(parcel.record.encodeProxyRecord()), \\\"proxy record invalid\\\");\\n    require(!isolate.isLiquidating, \\\"proxy is being liquidated\\\");\\n    uint256 fee = parcel.record.computeAdjustedKeeperFee(parcel.record.expected);\\n    pool = isolate.masterAddress;\\n    uint256 amount;\\n    if (!isolate.isRepaying) {\\n      isolate.isRepaying = true;\\n      isolate.actualizedShift = amount = mint(parcel);\\n    } else amount = isolate.actualizedShift;\\n    address[] memory set = isolate.repaymentSet.set;\\n    for (uint256 i = isolate.repaymentIndex; i < set.length; i++) {\\n      if (gasleft() < MINIMUM_GAS_CONTINUE || !set[i].delegateRepay()) {\\n        isolate.repaymentIndex = i;\\n        return (false, record, pool, 0);\\n      }\\n    }\\n    isolate.unbound = true;\\n    require(parcel.record.request.token.sendToken(parcel.record.loan.keeper, fee), \\\"keeper payout failed\\\");\\n    record.request.amount = amount;\\n    repayAmount = amount - fee;\\n    success = true;\\n  }\\n  function relayMint(address shifter, address token, bytes32 pHash, uint256 amount, bytes32 nHash, bytes memory darknodeSignature, uint256 fee) public returns (bool) {\\n    require(isolate.masterAddress == msg.sender, \\\"must be called by shifter pool\\\");\\n    IShifter(shifter).mint(pHash, amount, nHash, darknodeSignature);\\n    if (fee != 0) require(token.sendToken(msg.sender, fee), \\\"failed to send token\\\");\\n    isolate.unbound = true;\\n  }\\n  function getBalanceOf(address token, address user) internal view returns (uint256) {\\n    return IERC20(token).balanceOf(user);\\n  }\\n  function getLiquidityToken(address payable pool, address token) internal view returns (address liqToken) {\\n    liqToken = address(ShifterPool(pool).getLiquidityTokenHandler(token));\\n  }\\n  function maybeRelayResolveLoan(bool success, ShifterBorrowProxyLib.ProxyRecord memory record, address payable pool, uint256 repayPool) internal returns (bool) {\\n    if (success) {\\n      address liqToken = getLiquidityToken(pool, record.request.token);\\n      require(record.request.token.sendToken(pool, repayPool), \\\"failed to approve pool for token transfer\\\");\\n      require(ShifterPool(pool).relayResolveLoan(record.request.token, liqToken, record.loan.keeper, record.loan.params.bond, repayPool, record.expected), \\\"loan resolution failure\\\");\\n      return true;\\n    }\\n    return false;\\n  }\\n  function defaultLoan(bytes memory data) public {\\n    (bool success, ShifterBorrowProxyLib.ProxyRecord memory record, address payable pool, uint256 postBalance) = _defaultLoan(data);\\n    maybeRelayResolveLoan(success, record, pool, postBalance);\\n    _payoutCallbackGas(record.request.borrower, 0, _getGasReserved());\\n    selfdestruct(msg.sender);\\n  }\\n  function _defaultLoan(bytes memory data) internal returns (bool success, ShifterBorrowProxyLib.ProxyRecord memory record, address payable pool, uint256 postBalance) {\\n    require(!isolate.isRepaying, \\\"loan being repaid\\\");\\n    require(!isolate.unbound, \\\"loan already repaid\\\");\\n    require(validateProxyRecord(data), \\\"proxy record invalid\\\");\\n    record = data.decodeProxyRecord();\\n    address[] memory set = isolate.liquidationSet.set;\\n    if (record.loan.params.timeoutExpiry >= block.number) {\\n      isolate.isLiquidating = true;\\n      for (uint256 i = isolate.liquidationIndex; i < set.length; i++) {\\n        if (gasleft() < MINIMUM_GAS_CONTINUE || !set[i].delegateLiquidate()) {\\n          isolate.liquidationIndex = i;\\n          return (false, record, pool, postBalance);\\n        }\\n      }\\n      isolate.liquidationIndex = set.length;\\n      pool = isolate.masterAddress;\\n      postBalance = getBalanceOf(record.request.token, address(this));\\n      success = true;\\n    } else {\\n      success = false;\\n    }\\n  }\\n  function receiveInitializationActions(ShifterBorrowProxyLib.InitializationAction[] memory actions) public {\\n    require(msg.sender == address(isolate.masterAddress), \\\"must be called from shifter pool\\\");\\n    actions.processActions();\\n  }\\n  fallback() external payable override {}\\n  receive() external payable override {}\\n}\\n\",\"keccak256\":\"0xb01f539c03bed87cc72d0ac4e5372cc87bd37229bb94912792165a05a3dd79c7\",\"license\":\"MIT\"},\"contracts/ShifterBorrowProxyFactoryLib.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { Create2 } from \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\nimport { ShifterBorrowProxy } from \\\"./ShifterBorrowProxy.sol\\\";\\nimport { ShifterPoolLib } from \\\"./ShifterPoolLib.sol\\\";\\nimport { FactoryLib } from \\\"./FactoryLib.sol\\\";\\n\\nlibrary ShifterBorrowProxyFactoryLib {\\n  function deployBorrowProxy(ShifterPoolLib.Isolate storage /* isolate */, bytes32 salt) external returns (address output) {\\n    output = Create2.deploy(0, salt, type(ShifterBorrowProxy).creationCode);\\n  }\\n  function deriveBorrowerAddress(address target, bytes32 salt) internal view returns (address) {\\n    return FactoryLib.deriveInstanceAddress(target, salt);\\n  }\\n}\\n\",\"keccak256\":\"0xbc44f1c42b4824efcef7b657671a325692245b8da64262222b065c67deafcf16\",\"license\":\"MIT\"},\"contracts/ShifterBorrowProxyLib.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { IInitializationActionsReceiver } from \\\"./interfaces/IInitializationActionsReceiver.sol\\\";\\nimport { ECDSA } from \\\"@openzeppelin/contracts/cryptography/ECDSA.sol\\\";\\nimport { SafeMath } from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport { BorrowProxy } from \\\"./BorrowProxy.sol\\\";\\nimport { BorrowProxyLib } from \\\"./BorrowProxyLib.sol\\\";\\nimport { TokenUtils } from \\\"./utils/TokenUtils.sol\\\";\\nimport { RevertCaptureLib } from \\\"./utils/RevertCaptureLib.sol\\\";\\nimport { SandboxLib } from \\\"./utils/sandbox/SandboxLib.sol\\\";\\nimport { IShifter } from \\\"./interfaces/IShifter.sol\\\";\\nimport { IShifterERC20 } from \\\"./interfaces/IShifterERC20.sol\\\";\\n\\nlibrary ShifterBorrowProxyLib {\\n  using SafeMath for *;\\n  using TokenUtils for *;\\n  struct ProxyRecord {\\n    LiquidityRequest request;\\n    LenderRecord loan;\\n    uint256 expected;\\n  }\\n  struct LiquidityRequest {\\n    address payable borrower;\\n    address token;\\n    bytes32 nonce;\\n    uint256 amount;\\n    bool forbidLoan;\\n    InitializationAction[] actions;\\n  }\\n  struct InitializationAction {\\n    address to;\\n    bytes txData;\\n  }\\n  event BorrowProxyInitialization(address indexed proxyAddress, SandboxLib.ProtectedExecution[]);\\n  function emitBorrowProxyInitialization(address /* proxyAddress */, SandboxLib.ProtectedExecution[] memory /* trace */) internal {\\n//    emit BorrowProxyInitialization(proxyAddress, trace);\\n  }\\n    \\n  function encodeProxyRecord(ProxyRecord memory record) internal pure returns (bytes memory result) {\\n    result = abi.encode(record);\\n  }\\n  function decodeProxyRecord(bytes memory record) internal pure returns (ProxyRecord memory result) {\\n    (result) = abi.decode(record, (ProxyRecord));\\n  }\\n  struct LiquidityRequestParcel {\\n    LiquidityRequest request;\\n    uint256 gasRequested;\\n    bytes signature;\\n  }\\n  function computeDepositAddress(LiquidityRequestParcel memory /* parcel */, address /* mpkh */, bool /* btcTestnet */) internal pure returns (string memory result) {\\n    result = \\\"\\\";\\n  }\\n  struct LenderParams {\\n    uint256 timeoutExpiry;\\n    uint256 bond;\\n    uint256 poolFee;\\n    uint256 keeperFee;\\n  }\\n  struct LenderRecord {\\n    address keeper;\\n    LenderParams params;\\n  }\\n  event ShifterBorrowProxyRepaid(address indexed user, ProxyRecord record);\\n  function emitShifterBorrowProxyRepaid(address user, ProxyRecord memory record) internal {\\n    emit ShifterBorrowProxyRepaid(user, record);\\n  }\\n  function encodeBorrowerMessage(LiquidityRequest memory params, bytes memory parcelActionsEncoded) internal pure returns (bytes memory result) {\\n    result = abi.encodePacked(params.borrower, params.token, params.nonce, params.amount, params.forbidLoan, parcelActionsEncoded);\\n  }\\n  function computeBorrowerSalt(LiquidityRequest memory params) internal pure returns (bytes32 result) {\\n    result = keccak256(computeBorrowerSaltPreimage(params));\\n  }\\n  function computeBorrowerSaltPreimage(LiquidityRequest memory params) internal pure returns (bytes memory result) {\\n    bytes memory parcelActionsEncoded = encodeParcelActions(params.actions);\\n    result = encodeBorrowerMessage(params, parcelActionsEncoded);\\n  }\\n  function encodeParcelActions(InitializationAction[] memory actions) internal pure returns (bytes memory retval) {\\n    retval = abi.encode(actions);\\n  }\\n  function computeLiquidityRequestParcelMessage(LiquidityRequestParcel memory parcel, bytes memory parcelActionsEncoded) internal view returns (bytes memory retval) {\\n    retval = abi.encodePacked(address(this), parcel.request.token, parcel.request.nonce, parcel.request.amount, parcel.gasRequested, parcel.request.forbidLoan, parcelActionsEncoded);\\n  }\\n  function computeLiquidityRequestPreimage(LiquidityRequestParcel memory parcel) internal view returns (bytes memory result) {\\n    bytes memory parcelActionsEncoded = encodeParcelActions(parcel.request.actions);\\n    result = computeLiquidityRequestParcelMessage(parcel, parcelActionsEncoded);\\n  }\\n  function computeLiquidityRequestHash(LiquidityRequestParcel memory parcel) internal view returns (bytes32 result) {\\n    result = keccak256(computeLiquidityRequestPreimage(parcel));\\n  }\\n  function validateSignature(LiquidityRequestParcel memory parcel, bytes32 hash) internal pure returns (bool) {\\n    return parcel.request.borrower == ECDSA.recover(ECDSA.toEthSignedMessageHash(hash), parcel.signature);\\n  }\\n  function validateSignature(LiquidityRequestParcel memory parcel) internal view returns (bool) {\\n    return parcel.request.borrower == ECDSA.recover(ECDSA.toEthSignedMessageHash(computeLiquidityRequestHash(parcel)), parcel.signature);\\n  }\\n  struct ShiftParameters {\\n    bytes32 txhash;\\n    uint256 vout;\\n    bytes32 pHash;\\n    uint256 amount;\\n    bytes darknodeSignature;\\n  }\\n  struct TriggerParcel {\\n    ProxyRecord record;\\n    ShiftParameters shiftParameters;\\n  }\\n  struct SansBorrowShiftParcel {\\n    LiquidityRequestParcel liquidityRequestParcel;\\n    ShiftParameters shiftParameters;\\n    InitializationAction[] actions;\\n  }\\n  function decodeTriggerParcel(bytes memory parcel) internal pure returns (TriggerParcel memory result) {\\n    (result) = abi.decode(parcel, (TriggerParcel));\\n  }\\n  function encodeNPreimage(TriggerParcel memory parcel) internal pure returns (bytes memory result) {\\n    result = abi.encodePacked(parcel.record.request.nonce, parcel.shiftParameters.txhash, parcel.shiftParameters.vout);\\n  }\\n  function computeNHash(TriggerParcel memory parcel) internal pure returns (bytes32) {\\n    return keccak256(encodeNPreimage(parcel));\\n  }\\n  uint256 constant BIPS_DENOMINATOR = 10000;\\n  function computeExpectedAmount(uint256 amount, address shifter, address token) internal returns (uint256 expected) {\\n    uint256 mintFee = getMintFee(shifter);\\n    uint256 underlyingAmount = getUnderlyingAmount(token, amount);\\n    uint256 fee = underlyingAmount.mul(mintFee).div(BIPS_DENOMINATOR);\\n    expected = underlyingAmount.sub(fee);\\n  }\\n  function getMintFee(address shifter) internal view returns (uint256 mintFee) {\\n    mintFee = uint256(IShifter(shifter).mintFee());\\n  }\\n  function getUnderlyingAmount(address token, uint256 amount) internal returns (uint256 underlyingAmount) {\\n    underlyingAmount = IShifterERC20(token).fromUnderlying(amount);\\n  }\\n  function computePostFee(ProxyRecord memory record) internal pure returns (uint256) {\\n    return record.expected.sub(computePoolFee(record).add(computeKeeperFee(record)));\\n  }\\n  function computePoolFee(ProxyRecord memory record) internal pure returns (uint256) {\\n    return record.expected.mul(record.loan.params.poolFee).div(uint256(1 ether));\\n  }\\n  function computeKeeperFee(ProxyRecord memory record) internal pure returns (uint256) {\\n    return record.expected.mul(record.loan.params.keeperFee).div(uint256(1 ether));\\n  }\\n  function computeAdjustedKeeperFee(ProxyRecord memory record, uint256 actual) internal pure returns (uint256) {\\n    return actual.mul(record.loan.params.keeperFee).div(uint256(1 ether));\\n  }\\n}\\n\",\"keccak256\":\"0x974cd03066104f482be120f08df210b740c6262207e249850db2374ed48d1a97\",\"license\":\"MIT\"},\"contracts/ShifterPool.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport { IShifterRegistry } from \\\"./interfaces/IShifterRegistry.sol\\\";\\nimport { IShifter } from \\\"./interfaces/IShifter.sol\\\";\\nimport { ShifterPoolLib } from \\\"./ShifterPoolLib.sol\\\";\\nimport { ShifterBorrowProxyLib } from \\\"./ShifterBorrowProxyLib.sol\\\";\\nimport { ShifterBorrowProxyFactoryLib } from \\\"./ShifterBorrowProxyFactoryLib.sol\\\";\\nimport { ShifterBorrowProxy } from \\\"./ShifterBorrowProxy.sol\\\";\\nimport { BorrowProxy } from \\\"./BorrowProxy.sol\\\";\\nimport { BorrowProxyLib } from \\\"./BorrowProxyLib.sol\\\";\\nimport { TokenUtils } from \\\"./utils/TokenUtils.sol\\\";\\nimport { ViewExecutor } from \\\"./utils/ViewExecutor.sol\\\";\\nimport { LiquidityToken } from \\\"./LiquidityToken.sol\\\";\\nimport { SandboxLib } from \\\"./utils/sandbox/SandboxLib.sol\\\";\\nimport { SafeViewExecutor } from \\\"./utils/sandbox/SafeViewExecutor.sol\\\";\\nimport { FactoryLib } from \\\"./FactoryLib.sol\\\";\\nimport { NullCloneConstructor } from \\\"./NullCloneConstructor.sol\\\";\\nimport { AssetForwarderLib } from \\\"./adapters/lib/AssetForwarderLib.sol\\\";\\nimport { AssetForwarder } from \\\"./adapters/lib/AssetForwarder.sol\\\";\\nimport { ERC20 } from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport { StringLib } from \\\"./utils/StringLib.sol\\\";\\nimport { ExtLib } from \\\"./utils/ExtLib.sol\\\";\\nimport { SafeMath } from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport { Math } from \\\"@openzeppelin/contracts/math/Math.sol\\\";\\n\\ncontract ShifterPool is Ownable, SafeViewExecutor, NullCloneConstructor {\\n  using SandboxLib for *;\\n  using SafeMath for *;\\n  using ShifterPoolLib for *;\\n  using TokenUtils for *;\\n  using StringLib for *;\\n  using ExtLib for *;\\n  using ShifterBorrowProxyLib for *;\\n  using ShifterBorrowProxyFactoryLib for *;\\n  using BorrowProxyLib for *;\\n  ShifterPoolLib.Isolate isolate;\\n  constructor() Ownable() public {\\n    isolate.genesis = block.number;\\n  }\\n  function setup(ShifterPoolLib.SetupParams memory params, BorrowProxyLib.ModuleDetails[] memory moduleDetails, BorrowProxyLib.Module[] memory modules, ShifterPoolLib.LiquidityTokenLaunch[] memory tokenLaunches) public onlyOwner {\\n    require(modules.length == moduleDetails.length, \\\"can't zip module registations: modules.length != moduleDetails.length\\\");\\n    isolate.shifterRegistry = params.shifterRegistry;\\n    isolate.maxLoan = params.maxLoan;\\n    isolate.minTimeout = params.minTimeout;\\n    isolate.poolFee = params.poolFee;\\n    isolate.daoFee = params.daoFee;\\n    isolate.gasEstimate = params.gasEstimate;\\n    isolate.maxGasPriceForRefund = params.maxGasPriceForRefund;\\n    for (uint256 i = 0; i < modules.length; i++) {\\n      BorrowProxyLib.ModuleRegistration memory registration = BorrowProxyLib.ModuleRegistration({\\n        module: modules[i],\\n        target: moduleDetails[i].target,\\n        sigs: moduleDetails[i].sigs,\\n        moduleType: moduleDetails[i].moduleType\\n      });\\n      isolate.registry.registryRegisterModule(registration);\\n    }\\n    for (uint256 i = 0; i < tokenLaunches.length; i++) {\\n      ShifterPoolLib.LiquidityTokenLaunch memory launch = tokenLaunches[i];\\n      isolate.tokenToLiquidityToken[launch.token] = launch.liqToken;\\n      isolate.tokenToBaseFee[launch.token] = launch.baseFee;\\n    }\\n  }\\n  function getGasReserved(address proxyAddress) view public returns (uint256) {\\n    return isolate.gasReserved[proxyAddress];\\n  }\\n  function payoutCallbackGas(address payable borrower, uint256 amountBorrower, uint256 amountOrigin) public {\\n    if (amountOrigin != 0) tx.origin.send(amountOrigin);\\n    if (amountBorrower != 0) borrower.send(amountBorrower);\\n  }\\n  function getLiquidityTokenForTokenHandler(address token) public view returns (address) {\\n    return isolate.tokenToLiquidityToken[token];\\n  }\\n  bytes32 constant BORROW_PROXY_IMPLEMENTATION_SALT = 0xfe1e3164ba4910db3c9afd049cd8feb4552390569c846692e6df4ac68aeaa90e;\\n  function deployBorrowProxyImplementation() public {\\n    require(isolate.borrowProxyImplementation == address(0x0), \\\"already deployed\\\");\\n    isolate.borrowProxyImplementation = isolate.makeBorrowProxy(BORROW_PROXY_IMPLEMENTATION_SALT);\\n    address payable borrowProxyImplementation = address(uint160(isolate.borrowProxyImplementation));\\n//    borrowProxyImplementation.setupBorrowProxy(address(0x1), address(0x1), false);\\n  }\\n  function computeProxyAddress(bytes32 salt) public view returns (address) {\\n    return isolate.borrowProxyImplementation.deriveBorrowerAddress(salt);\\n  }\\n  function deployAssetForwarderImplementation() public {\\n    require(isolate.assetForwarderImplementation == address(0x0), \\\"already deployed\\\");\\n    isolate.assetForwarderImplementation = AssetForwarderLib.deployAssetForwarder();\\n    AssetForwarder(isolate.assetForwarderImplementation).lock();\\n  }\\n\\n  function deployAssetForwarderClone(bytes32 salt) public returns (address created) {\\n\\n    created = FactoryLib.create2Clone(isolate.assetForwarderImplementation, uint256(keccak256(abi.encodePacked(AssetForwarderLib.GET_ASSET_FORWARDER_IMPLEMENTATION_SALT(), msg.sender, salt))));\\n\\n  }\\n  function getAssetForwarderImplementationHandler() public view returns (address implementation) {\\n    return isolate.assetForwarderImplementation;\\n  }\\n  function deployBorrowProxyClone(bytes32 salt) internal returns (address payable created) {\\n    created = address(uint160(FactoryLib.create2Clone(isolate.borrowProxyImplementation, uint256(salt))));\\n  }\\n  function validateUnderMaxLoan(ShifterBorrowProxyLib.LiquidityRequestParcel memory parcel) internal view returns (bool) {\\n    uint8 decimals = ERC20(parcel.request.token).decimals();\\n    require(decimals <= 18, \\\"the token supplied is not a shifter token -- decimals too high\\\");\\n    require(parcel.request.amount / 10**(18 - uint256(decimals)) <= isolate.maxLoan, \\\"loan exceeds maximum\\\");\\n  }\\n  function _executeBorrow(ShifterPoolLib.BorrowState memory state, ShifterBorrowProxyLib.LiquidityRequestParcel memory liquidityRequestParcel, uint256 bond, uint256 timeoutExpiry) internal returns (address payable proxyAddress) {\\n    require(liquidityRequestParcel.request.forbidLoan == false, \\\"is not a loan request, try using executeShiftSansBorrow\\\");\\n    require(\\n      liquidityRequestParcel.gasRequested == msg.value,\\n      \\\"supplied ether is not equal to gas requested\\\"\\n  \\n    );\\n    require(\\n      liquidityRequestParcel.validateSignature(\\n        liquidityRequestParcel.computeLiquidityRequestHash()\\n      ),\\n      \\\"liquidity request signature rejected\\\"\\n    );\\n    ShifterBorrowProxyLib.LiquidityRequest memory liquidityRequest = liquidityRequestParcel.request;\\n    bytes32 borrowerSalt = liquidityRequest.computeBorrowerSalt();\\n    liquidityRequest.actions = new ShifterBorrowProxyLib.InitializationAction[](0);\\n    ShifterBorrowProxyLib.ProxyRecord memory proxyRecord = ShifterBorrowProxyLib.ProxyRecord({\\n      request: liquidityRequest,\\n      loan: ShifterBorrowProxyLib.LenderRecord(\\n        msg.sender,\\n        isolate.computeLoanParams(liquidityRequest.amount, bond, timeoutExpiry)\\n      ),\\n      expected: liquidityRequest.amount.computeExpectedAmount(address(isolate.getShifter(liquidityRequest.token)), liquidityRequest.token).sub(isolate.tokenToBaseFee[liquidityRequest.token])\\n    });\\n    proxyAddress = address(uint160(deployBorrowProxyClone(borrowerSalt)));\\n    ShifterPoolLib.mapBorrowProxy(isolate, proxyAddress, proxyRecord);\\n    isolate.issueLoan(liquidityRequest.token, proxyAddress, proxyRecord.computePostFee(), state.refundAmount);\\n    require(liquidityRequest.token.transferTokenFrom(msg.sender, address(this), bond), \\\"bond submission failed\\\");\\n  }\\n  function executeBorrow(ShifterBorrowProxyLib.LiquidityRequestParcel memory liquidityRequestParcel, uint256 bond, uint256 timeoutExpiry) public payable {\\n    ShifterPoolLib.BorrowState memory state = ShifterPoolLib.BorrowState({\\n      refundAmount: 0,\\n      gasPrice: Math.min(isolate.maxGasPriceForRefund, tx.gasprice),\\n      startGas: gasleft()\\n    });\\n    state.refundAmount = state.gasPrice*isolate.gasEstimate;\\n    require(isolate.isKeeper[msg.sender], \\\"only can be called by keeper\\\");\\n    ShifterBorrowProxyLib.InitializationAction[] memory actions = liquidityRequestParcel.request.actions;\\n    validateUnderMaxLoan(liquidityRequestParcel);\\n    address payable proxyAddress = _executeBorrow(state, liquidityRequestParcel, bond, timeoutExpiry);\\n    proxyAddress.setupBorrowProxy(liquidityRequestParcel.request.borrower, liquidityRequestParcel.request.token, false);\\n    proxyAddress.sendInitializationActions(actions);\\n    state.startGas = Math.min(state.refundAmount, (state.startGas - gasleft()  + 8600)*state.gasPrice); // estimate 10000 for additional gas, should be close\\n    tx.origin.transfer(state.startGas); // just reuse this memory loc, startGas becomes total amount refunded\\n    isolate.gasReserved[proxyAddress] = state.refundAmount - state.startGas;\\n  }\\n  function setKeeper(address user, bool isKeeper) public onlyOwner {\\n    isolate.isKeeper[user] = isKeeper;\\n  }\\n  function executeShiftSansBorrow(ShifterBorrowProxyLib.SansBorrowShiftParcel memory parcel) public payable {\\n    (address payable proxyAddress, ShifterBorrowProxyLib.InitializationAction[] memory actions) = _executeShiftSansBorrow(parcel);\\n    if (actions.length != 0) proxyAddress.sendInitializationActions(actions);\\n  }\\n  function _executeShiftSansBorrow(ShifterBorrowProxyLib.SansBorrowShiftParcel memory parcel) internal returns (address payable proxyAddress, ShifterBorrowProxyLib.InitializationAction[] memory actions) {\\n    ShifterBorrowProxyLib.TriggerParcel memory triggerParcel = ShifterBorrowProxyLib.TriggerParcel({\\n      record: ShifterBorrowProxyLib.ProxyRecord({\\n        expected: parcel.liquidityRequestParcel.request.amount,\\n        request: parcel.liquidityRequestParcel.request,\\n        loan: ShifterBorrowProxyLib.LenderRecord({\\n          keeper: msg.sender,\\n          params: isolate.computeLoanParams(parcel.liquidityRequestParcel.request.amount, parcel.liquidityRequestParcel.request.amount / 10, 1000)\\n        })\\n      }),\\n      shiftParameters: ShifterBorrowProxyLib.ShiftParameters({\\n        txhash: parcel.shiftParameters.txhash,\\n        amount: parcel.shiftParameters.amount,\\n        vout: parcel.shiftParameters.vout,\\n        pHash: parcel.shiftParameters.pHash,\\n        darknodeSignature: parcel.shiftParameters.darknodeSignature\\n      })\\n    });\\n    require(\\n      parcel.liquidityRequestParcel.validateSignature(\\n        parcel.liquidityRequestParcel.computeLiquidityRequestHash()\\n      ),\\n      \\\"liquidity request signature rejected\\\"\\n    );\\n    bytes32 borrowerSalt = parcel.liquidityRequestParcel.request.computeBorrowerSalt();\\n    proxyAddress = address(uint160(isolate.borrowProxyImplementation.deriveBorrowerAddress(borrowerSalt)));\\n    require(!proxyAddress.isContract(), \\\"proxy has already been initialized\\\");\\n    isolate.borrowProxyController.mapProxyRecord(proxyAddress, abi.encodePacked(uint256(1)));\\n    uint256 fee = triggerParcel.record.computeAdjustedKeeperFee(parcel.shiftParameters.amount);\\n    deployBorrowProxyClone(borrowerSalt);\\n    proxyAddress.setupBorrowProxy(parcel.liquidityRequestParcel.request.borrower, parcel.liquidityRequestParcel.request.token, true);\\n    if (parcel.liquidityRequestParcel.request.borrower != msg.sender && msg.value == parcel.liquidityRequestParcel.gasRequested) {\\n      parcel.liquidityRequestParcel.request.borrower.transfer(msg.value);\\n      ShifterPoolLib.sendMint(proxyAddress, address(isolate.getShifter(parcel.liquidityRequestParcel.request.token)), parcel, triggerParcel.computeNHash(), fee);\\n      require(parcel.liquidityRequestParcel.request.token.sendToken(msg.sender, fee), \\\"keeper payout failed\\\");\\n      actions = parcel.liquidityRequestParcel.request.actions;\\n    } else if (parcel.liquidityRequestParcel.request.borrower == msg.sender) {\\n      ShifterPoolLib.sendMint(proxyAddress, address(isolate.getShifter(parcel.liquidityRequestParcel.request.token)), parcel, triggerParcel.computeNHash(), 0);\\n      actions = parcel.actions;\\n    }\\n\\n    else revert(\\\"incorrect gas supplied with gas requested\\\");\\n  }\\n  function validateProxyRecordHandler(bytes memory proxyRecord) public view returns (bool) {\\n    return isolate.borrowProxyController.validateProxyRecord(msg.sender, proxyRecord);\\n  }\\n  function getProxyTokenHandler(address proxyAddress) public view returns (address) {\\n    return isolate.borrowProxyController.getProxyToken(proxyAddress);\\n  }\\n  function getProxyOwnerHandler(address user) public view returns (address) {\\n    return isolate.borrowProxyController.getProxyOwner(user);\\n  }\\n  function getShifterHandler(address token) public view returns (IShifter) {\\n    return isolate.getShifter(token);\\n  }\\n  function getLiquidityTokenHandler(address token) public view returns (LiquidityToken) {\\n    return LiquidityToken(isolate.getLiquidityToken(token));\\n  }\\n  function fetchModuleHandler(address to, bytes4 sig) public view returns (BorrowProxyLib.Module memory) {\\n    return isolate.registry.resolveModule(to, sig);\\n  }\\n  function relayResolveLoan(address token, address liquidityToken, address keeper, uint256 bond, uint256 repay, uint256 originalAmount) public returns (bool) {\\n    require(isolate.borrowProxyController.proxyInitializerRecord[msg.sender] != bytes32(0x0), \\\"not a registered borrow proxy\\\");\\n    if (repay < originalAmount) {\\n      if (repay + bond < originalAmount) {\\n        repay = repay + bond;\\n        bond = 0;\\n      } else {\\n        bond -= originalAmount - repay;\\n        repay = originalAmount;\\n      }\\n    }\\n    if (bond != 0) require(token.sendToken(keeper, bond), \\\"failed to return bond to keeper\\\");\\n    if (repay != 0) {\\n       (uint256 amount, uint256 daoAmount) = ShifterPoolLib.splitForDAO(repay, isolate.daoFee);\\n       require(token.sendToken(liquidityToken, amount), \\\"failed to repay lost funds\\\");\\n       require(token.sendToken(owner(), daoAmount), \\\"failed to repay the governing DAO\\\");\\n    }\\n    require(LiquidityToken(liquidityToken).resolveLoan(msg.sender), \\\"loan resolution failure\\\");\\n    return true;\\n  }\\n  receive() external payable { }\\n}\\n\",\"keccak256\":\"0x05fa02498f26032b84151eefbafadaca002e5a99c51f34995a292b07cbdc2db7\",\"license\":\"MIT\"},\"contracts/ShifterPoolLib.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { ECDSA } from \\\"@openzeppelin/contracts/cryptography/ECDSA.sol\\\";\\nimport { TokenUtils } from \\\"./utils/TokenUtils.sol\\\";\\nimport { SafeMath } from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport { BorrowProxyLib } from \\\"./BorrowProxyLib.sol\\\";\\nimport { IShifter } from \\\"./interfaces/IShifter.sol\\\";\\nimport { IShifterRegistry } from \\\"./interfaces/IShifterRegistry.sol\\\";\\nimport { LiquidityToken } from \\\"./LiquidityToken.sol\\\";\\nimport { ShifterBorrowProxy } from \\\"./ShifterBorrowProxy.sol\\\";\\nimport { ShifterBorrowProxyLib } from \\\"./ShifterBorrowProxyLib.sol\\\";\\nimport { ShifterBorrowProxyFactoryLib } from \\\"./ShifterBorrowProxyFactoryLib.sol\\\";\\nimport { FactoryLib } from \\\"./FactoryLib.sol\\\";\\nimport { ShifterPool } from \\\"./ShifterPool.sol\\\";\\nimport { AssetForwarderLib } from \\\"./adapters/lib/AssetForwarderLib.sol\\\";\\n\\nlibrary ShifterPoolLib {\\n  using BorrowProxyLib for *;\\n  using TokenUtils for *;\\n  using ShifterBorrowProxyLib for *;\\n  using ShifterBorrowProxyFactoryLib for *;\\n  using SafeMath for *;\\n  struct SetupParams {\\n    address shifterRegistry;\\n    uint256 minTimeout;\\n    uint256 poolFee;\\n    uint256 daoFee;\\n    uint256 maxLoan;\\n    uint256 gasEstimate;\\n    uint256 maxGasPriceForRefund;\\n  }\\n  struct BorrowState {\\n    uint256 startGas;\\n    uint256 gasPrice;\\n    uint256 refundAmount;\\n  }\\n  struct Isolate {\\n    uint256 genesis;\\n    address borrowProxyImplementation;\\n    address assetForwarderImplementation;\\n    address shifterRegistry;\\n    uint256 minTimeout;\\n    uint256 poolFee;\\n    uint256 daoFee;\\n    uint256 maxLoan;\\n    uint256 gasEstimate;\\n    uint256 maxGasPriceForRefund;\\n    mapping (address => uint256) gasReserved;\\n    mapping (address => bool) isKeeper;\\n    mapping (bytes32 => bool) provisionExecuted;\\n    mapping (address => address) tokenToLiquidityToken;\\n    mapping (address => uint256) tokenToBaseFee;\\n    BorrowProxyLib.ControllerIsolate borrowProxyController;\\n    BorrowProxyLib.ModuleRegistry registry;\\n  }\\n  function splitForDAO(uint256 actualAmount, uint256 daoFee) internal pure returns (uint256 amount, uint256 daoAmount) {\\n    daoAmount = actualAmount.mul(uint256(daoFee)).div(uint256(1 ether));\\n    if (daoAmount < actualAmount) {\\n      amount = actualAmount - daoAmount;\\n    } else daoAmount = actualAmount;\\n  }\\n  function deployAssetForwarder(BorrowProxyLib.ProxyIsolate storage isolate, bytes32 salt) internal returns (address created) {\\n    return ShifterPool(isolate.masterAddress).deployAssetForwarderClone(salt);\\n  }\\n  function sendMint(address proxyAddress, address shifter, ShifterBorrowProxyLib.SansBorrowShiftParcel memory parcel, bytes32 nHash, uint256 fee) internal  {\\n    ShifterBorrowProxy(address(uint160(proxyAddress))).relayMint(shifter, parcel.liquidityRequestParcel.request.token, parcel.shiftParameters.pHash, parcel.shiftParameters.amount, nHash, parcel.shiftParameters.darknodeSignature, fee);\\n  }\\n  function makeBorrowProxy(Isolate storage isolate, bytes32 salt) internal returns (address payable proxyAddress) {\\n    proxyAddress = address(uint160(isolate.deployBorrowProxy(salt)));\\n  }\\n  function issueLoan(Isolate storage isolate, address token, address payable proxyAddress, uint256 fee, uint256 getGas) internal {\\n    require(LiquidityToken(getLiquidityToken(isolate, token)).loan(proxyAddress, fee, getGas), \\\"insufficient funds in liquidity pool\\\");\\n  }\\n  function setupBorrowProxy(address payable proxyAddress, address borrower, address token, bool unbound) internal {\\n    require(ShifterBorrowProxy(proxyAddress).setup(borrower, token, unbound), \\\"setup phase failure\\\");\\n  }\\n  function sendInitializationActions(address payable proxyAddress, ShifterBorrowProxyLib.InitializationAction[] memory actions) internal {\\n    ShifterBorrowProxy(proxyAddress).receiveInitializationActions(actions);\\n  }\\n  function computeLoanParams(Isolate storage isolate, uint256 amount, uint256 bond, uint256 timeoutExpiry) internal view returns (ShifterBorrowProxyLib.LenderParams memory) {\\n    require(timeoutExpiry >= isolate.minTimeout, \\\"timeout insufficient\\\");\\n    uint256 baseKeeperFee = uint256(1 ether).div(100); // 1%\\n    require(bond.mul(uint256(1 ether)).div(amount) > uint256(1 ether).div(100), \\\"bond below minimum\\\");\\n    uint256 keeperFee = amount < bond ? baseKeeperFee : uint256(baseKeeperFee).mul(bond).div(amount);\\n    return ShifterBorrowProxyLib.LenderParams({\\n      keeperFee: keeperFee,\\n      poolFee: isolate.poolFee,\\n      timeoutExpiry: block.number + timeoutExpiry,\\n      bond: bond\\n    });\\n  }\\n  struct LiquidityProvisionMessage {\\n    uint256 amount;\\n    uint256 nonce;\\n    uint256 keeperFee;\\n    uint256 timeoutExpiry;\\n    bytes signature;\\n  }\\n  struct LiquidityTokenLaunch {\\n    address token;\\n    address liqToken;\\n    uint256 baseFee;\\n  }\\n  function launchLiquidityToken(Isolate storage isolate, address weth, address router, address token, string memory name, string memory symbol, uint8 decimals) internal returns (address) {\\n    require(isolate.tokenToLiquidityToken[token] == address(0x0), \\\"already deployed liquidity token for target token\\\");\\n    address liquidityToken = address(new LiquidityToken(weth, router, address(uint160(address(this))), token, name, symbol, decimals));\\n    isolate.tokenToLiquidityToken[token] = liquidityToken;\\n    return liquidityToken;\\n  }\\n  function getLiquidityToken(Isolate storage isolate, address token) internal view returns (address) {\\n    address retval = isolate.tokenToLiquidityToken[token];\\n    require(retval != address(0x0), \\\"not a registered liquidity token\\\");\\n    return retval;\\n  }\\n  function lendLiquidity(Isolate storage isolate, address provider, address token, address target, uint256 amount) internal returns (bool) {\\n    if (!isolate.isKeeper[provider]) return false;\\n    return token.transferTokenFrom(provider, target, amount);\\n  }\\n  function getShifter(Isolate storage isolate, address token) internal view returns (IShifter) {\\n    return IShifterRegistry(isolate.shifterRegistry).getGatewayByToken(token);\\n  }\\n  function provisionHashAlreadyUsed(Isolate storage isolate, bytes32 provisionHash) internal view returns (bool) {\\n    return isolate.provisionExecuted[provisionHash];\\n  }\\n  function preventProvisionReplay(Isolate storage isolate, bytes32 provisionHash) internal returns (bool) {\\n    isolate.provisionExecuted[provisionHash] = true;\\n    return true;\\n  }\\n  function mapBorrowProxy(Isolate storage isolate, address proxyAddress, ShifterBorrowProxyLib.ProxyRecord memory record) internal {\\n    bytes memory data = record.encodeProxyRecord();\\n    isolate.borrowProxyController.setProxyToken(proxyAddress, record.request.token);\\n    isolate.borrowProxyController.setProxyOwner(proxyAddress, record.request.borrower);\\n    record.request.borrower.transfer(msg.value);\\n    isolate.borrowProxyController.mapProxyRecord(proxyAddress, data);\\n    BorrowProxyLib.emitBorrowProxyMade(record.request.borrower, proxyAddress, data);\\n  }\\n}   \\n\",\"keccak256\":\"0xcfc0caf1ef935221855162c473f404ca96dfb89dc49ff1b3c2c39d33d09d7d6f\",\"license\":\"MIT\"},\"contracts/adapters/assets/erc20/ERC20Adapter.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { ModuleLib } from \\\"../../lib/ModuleLib.sol\\\";\\nimport { ERC20 } from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport { ERC20AdapterLib } from \\\"./ERC20AdapterLib.sol\\\";\\nimport { TokenUtils } from \\\"../../../utils/TokenUtils.sol\\\";\\nimport { BorrowProxyLib } from \\\"../../../BorrowProxyLib.sol\\\";\\n\\ncontract ERC20Adapter {\\n  using ERC20AdapterLib for *;\\n  using ModuleLib for *;\\n  using TokenUtils for *;\\n  BorrowProxyLib.ProxyIsolate proxyIsolate;\\n  function getExternalIsolateHandler() external pure returns (ERC20AdapterLib.Isolate memory) {\\n    return ERC20AdapterLib.getIsolatePointer();\\n  }\\n  function repay(address /* moduleAddress */)  public returns (bool) {\\n    return proxyIsolate.processEscrowForwards();\\n  }\\n  function handle(ModuleLib.AssetSubmodulePayload memory payload) public payable {\\n    (bytes4 sig, bytes memory args) = payload.callData.splitPayload();\\n    if (sig == ERC20.transfer.selector) {\\n       ERC20AdapterLib.TransferInputs memory inputs = args.decodeTransferInputs();\\n       require(proxyIsolate.sendToEscrow(inputs.recipient, payload.to, inputs.amount), \\\"token transfer to escrow wallet failed\\\");\\n    } else if (sig == ERC20.approve.selector) {\\n      // do nothing\\n    } else revert(\\\"unsupported token call\\\");\\n  }\\n}\\n\",\"keccak256\":\"0x96a2ac675f7b0bf53f9af6c35b29490c37d693ea1d55f83fcaacfd6d04a56a25\",\"license\":\"MIT\"},\"contracts/adapters/assets/erc20/ERC20AdapterLib.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { Create2 } from \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { ModuleLib } from \\\"../../lib/ModuleLib.sol\\\";\\nimport { AssetForwarder } from \\\"../../lib/AssetForwarder.sol\\\";\\nimport { AssetForwarderLib } from \\\"../../lib/AssetForwarderLib.sol\\\";\\nimport { ERC20Adapter } from \\\"./ERC20Adapter.sol\\\";\\nimport { BorrowProxyLib } from \\\"../../../BorrowProxyLib.sol\\\";\\nimport { StringLib } from \\\"../../../utils/StringLib.sol\\\";\\nimport { ShifterPoolLib } from \\\"../../../ShifterPoolLib.sol\\\";\\nimport { TokenUtils } from \\\"../../../utils/TokenUtils.sol\\\";\\nimport { FactoryLib } from \\\"../../../FactoryLib.sol\\\";\\nimport { ShifterPool } from \\\"../../../ShifterPool.sol\\\";\\n\\nlibrary ERC20AdapterLib {\\n  using ShifterPoolLib for *;\\n  using TokenUtils for *;\\n  using StringLib for *;\\n  struct EscrowRecord {\\n    address recipient;\\n    address token;\\n  }\\n  struct Isolate {\\n    EscrowRecord[] payments;\\n    bool isProcessing;\\n    uint256 processed;\\n  }\\n  function isDone(Isolate storage isolate) internal view returns (bool) {\\n    return !isolate.isProcessing && isolate.payments.length == isolate.processed;\\n  }\\n  function computeIsolatePointer() public pure returns (uint256) {\\n    return uint256(keccak256(\\\"isolate.erc20-adapter\\\"));\\n  }\\n  function computeForwarderSalt(uint256 index) internal pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(index));\\n  }\\n  function computeForwarderAddress(BorrowProxyLib.ProxyIsolate storage proxyIsolate, uint256 index) internal view returns (address) {\\n    return FactoryLib.deriveInstanceAddress(proxyIsolate.masterAddress, ShifterPool(proxyIsolate.masterAddress).getAssetForwarderImplementationHandler(), keccak256(abi.encodePacked(AssetForwarderLib.GET_ASSET_FORWARDER_IMPLEMENTATION_SALT(), address(this), computeForwarderSalt(index))));\\n  }\\n  function liquidate(BorrowProxyLib.ProxyIsolate storage proxyIsolate) internal returns (bool) {\\n    return processEscrowReturns(proxyIsolate);\\n  }\\n  struct TransferInputs {\\n    address recipient;\\n    uint256 amount;\\n  }\\n  function decodeTransferInputs(bytes memory args) internal pure returns (TransferInputs memory) {\\n    (address recipient, uint256 amount) = abi.decode(args, (address, uint256));\\n    return TransferInputs({\\n      recipient: recipient,\\n      amount: amount\\n    });\\n  }\\n  event Log(address indexed data);\\n  function forwardEscrow(BorrowProxyLib.ProxyIsolate storage proxyIsolate, EscrowRecord memory record, uint256 index) internal {\\n    address forwarder = proxyIsolate.deployAssetForwarder(computeForwarderSalt(index));\\n    emit Log(forwarder);\\n    emit Log(computeForwarderAddress(proxyIsolate, index));\\n    AssetForwarder(forwarder).forwardAsset(address(uint160(record.recipient)), record.token);\\n  }\\n  function returnEscrow(BorrowProxyLib.ProxyIsolate storage proxyIsolate, EscrowRecord memory record, uint256 index) internal {\\n    address forwarder = proxyIsolate.deployAssetForwarder(computeForwarderSalt(index));\\n    AssetForwarder(forwarder).forwardAsset(address(uint160(address(this))), record.token);\\n  }\\n  uint256 constant MINIMUM_GAS_TO_PROCESS = 5e5;\\n  uint256 constant MAX_RECORDS = 100;\\n  function processEscrowForwards(BorrowProxyLib.ProxyIsolate storage proxyIsolate) internal returns (bool) {\\n    Isolate storage isolate = getIsolatePointer();\\n    if (!isolate.isProcessing) isolate.isProcessing = true;\\n    for (uint256 i = isolate.processed; i < isolate.payments.length; i++) {\\n      if (gasleft() < MINIMUM_GAS_TO_PROCESS) {\\n        isolate.processed = i;\\n        return false;\\n      } else {\\n        forwardEscrow(proxyIsolate, isolate.payments[i], i);\\n      }\\n    }\\n    return true;\\n  }\\n  function processEscrowReturns(BorrowProxyLib.ProxyIsolate storage proxyIsolate) internal returns (bool) {\\n    Isolate storage isolate = getIsolatePointer();\\n    if (!isolate.isProcessing) isolate.isProcessing = true;\\n    for (uint256 i = isolate.processed; i < isolate.payments.length; i++) {\\n      if (gasleft() < MINIMUM_GAS_TO_PROCESS) {\\n        isolate.processed = i;\\n        return false;\\n      } else {\\n        returnEscrow(proxyIsolate, isolate.payments[i], i);\\n      }\\n    }\\n    return true;\\n  }\\n  function sendToEscrow(BorrowProxyLib.ProxyIsolate storage proxyIsolate, address recipient, address token, uint256 amount) internal returns (bool) {\\n     Isolate storage isolate = getIsolatePointer();\\n     address escrowWallet = computeForwarderAddress(proxyIsolate, isolate.payments.length);\\n     installEscrowRecord(recipient, token);\\n     return token.sendToken(escrowWallet, amount);\\n  }\\n  function installEscrowRecord(address recipient, address token) internal {\\n    Isolate storage isolate = getIsolatePointer();\\n    isolate.payments.push(EscrowRecord({\\n      recipient: recipient,\\n      token: token\\n    }));\\n  }\\n  function deriveNextForwarderAddress(BorrowProxyLib.ProxyIsolate storage proxyIsolate) internal view returns (address) {\\n    Isolate storage isolate = getIsolatePointer();\\n    return computeForwarderAddress(proxyIsolate, isolate.payments.length);\\n  }\\n  function getCastStorageType() internal pure returns (function (uint256) internal pure returns (Isolate storage) swap) {\\n    function (uint256) internal returns (uint256) cast = ModuleLib.cast;\\n    assembly {\\n      swap := cast\\n    }\\n  }\\n  function toIsolatePointer(uint256 key) internal pure returns (Isolate storage) {\\n    return getCastStorageType()(key);\\n  }\\n  function getIsolatePointer() internal pure returns (Isolate storage) {\\n    return toIsolatePointer(computeIsolatePointer());\\n  }\\n}\\n\",\"keccak256\":\"0x943c1d8ce5276841a1034829ea0a6f3a3f9b8c7c6e8c271190a4972a0dc8131c\",\"license\":\"MIT\"},\"contracts/adapters/assets/uniswap-v2/UniswapV2Adapter.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { IUniswapV2Router01 } from \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { TokenUtils } from \\\"../../../utils/TokenUtils.sol\\\";\\nimport { ModuleLib } from \\\"../../lib/ModuleLib.sol\\\";\\nimport { UniswapV2AdapterLib } from \\\"./UniswapV2AdapterLib.sol\\\";\\nimport { BorrowProxyLib } from \\\"../../../BorrowProxyLib.sol\\\";\\nimport { ERC20AdapterLib } from \\\"../erc20/ERC20AdapterLib.sol\\\";\\nimport { ShifterPool } from \\\"../../../ShifterPool.sol\\\";\\n\\ncontract UniswapV2Adapter {\\n  using TokenUtils for *;\\n  using ModuleLib for *;\\n  using BorrowProxyLib for *;\\n  using UniswapV2AdapterLib for *;\\n  using ERC20AdapterLib for *;\\n  BorrowProxyLib.ProxyIsolate proxyIsolate;\\n  constructor(address erc20Module) public {\\n    UniswapV2AdapterLib.Isolate storage isolate = UniswapV2AdapterLib.getIsolatePointer(address(this));\\n    isolate.erc20Module = erc20Module;\\n  }\\n  function validateIsERC20Module(ModuleLib.AssetSubmodulePayload memory payload, address token) internal view returns (bool) {\\n    UniswapV2AdapterLib.Isolate memory externalIsolate = UniswapV2AdapterLib.getExternalIsolate(payload.moduleAddress);\\n    require(ShifterPool(proxyIsolate.masterAddress).fetchModuleHandler(token, IERC20.transfer.selector).assetSubmodule == externalIsolate.erc20Module, \\\"asset is not associated with the ERC20 module\\\");\\n  }\\n  function getExternalIsolateHandler() external view returns (UniswapV2AdapterLib.Isolate memory) {\\n    return UniswapV2AdapterLib.getIsolatePointer(address(this));\\n  }\\n  function getWETH(ModuleLib.AssetSubmodulePayload memory payload) internal pure returns (address) {\\n    return IUniswapV2Router01(payload.to).WETH();\\n  }\\n  function handle(ModuleLib.AssetSubmodulePayload memory payload) public payable {\\n    (bytes4 sig, bytes memory args) = payload.callData.splitPayload();\\n    bool shouldTriggerERC20Handlers = false;\\n    address escrowWallet = proxyIsolate.deriveNextForwarderAddress();\\n    address newToken = address(0x0);\\n    address startToken = address(0x0);\\n    if (sig == IUniswapV2Router01.swapExactTokensForTokens.selector) {\\n      UniswapV2AdapterLib.SwapExactTokensForTokensInputs memory inputs = args.decodeSwapExactTokensForTokensInputs();\\n      address WETH = getWETH(payload);\\n      (startToken, newToken) = inputs.path.validatePath(WETH);\\n      validateIsERC20Module(payload, newToken);\\n      if (inputs.to != address(this)) {\\n        payload.callData = inputs.changeRecipient(escrowWallet).encodeWithSelector();\\n        shouldTriggerERC20Handlers = true;\\n        ERC20AdapterLib.installEscrowRecord(inputs.to, newToken);\\n      }\\n    } else if (sig == IUniswapV2Router01.swapTokensForExactTokens.selector) {\\n      UniswapV2AdapterLib.SwapTokensForExactTokensInputs memory inputs = args.decodeSwapTokensForExactTokensInputs();\\n      address WETH = getWETH(payload);\\n      (startToken, newToken) = inputs.path.validatePath(WETH);\\n      validateIsERC20Module(payload, newToken);\\n      if (inputs.to != address(this)) {\\n        payload.callData = inputs.changeRecipient(escrowWallet).encodeWithSelector();\\n        shouldTriggerERC20Handlers = true;\\n        ERC20AdapterLib.installEscrowRecord(inputs.to, newToken);\\n      }\\n    } else if (sig == IUniswapV2Router01.swapExactETHForTokens.selector) {\\n      UniswapV2AdapterLib.SwapExactETHForTokensInputs memory inputs = args.decodeSwapExactETHForTokensInputs();\\n      address WETH = getWETH(payload);\\n      (startToken, newToken) = inputs.path.validatePath(WETH);\\n      validateIsERC20Module(payload, newToken);\\n      if (inputs.to != address(this)) {\\n        payload.callData = inputs.changeRecipient(escrowWallet).encodeWithSelector();\\n        shouldTriggerERC20Handlers = true;\\n        ERC20AdapterLib.installEscrowRecord(inputs.to, newToken);\\n      }\\n    } else if (sig == IUniswapV2Router01.swapTokensForExactETH.selector) {\\n      UniswapV2AdapterLib.SwapExactETHForTokensInputs memory inputs = args.decodeSwapExactETHForTokensInputs();\\n      address WETH = getWETH(payload);\\n      (startToken, newToken) = inputs.path.validatePath(WETH);\\n      validateIsERC20Module(payload, newToken);\\n      if (inputs.to != address(this)) {\\n        payload.callData = inputs.changeRecipient(escrowWallet).encodeWithSelector();\\n        shouldTriggerERC20Handlers = true;\\n        ERC20AdapterLib.installEscrowRecord(inputs.to, newToken);\\n      }\\n    } else if (sig == IUniswapV2Router01.swapExactTokensForETH.selector) {\\n      UniswapV2AdapterLib.SwapExactTokensForETHInputs memory inputs = args.decodeSwapExactTokensForETHInputs();\\n      address WETH = getWETH(payload);\\n      (startToken, newToken) = inputs.path.validatePath(WETH);\\n      validateIsERC20Module(payload, newToken);\\n      if (inputs.to != address(this)) {\\n        payload.callData = inputs.changeRecipient(escrowWallet).encodeWithSelector();\\n        shouldTriggerERC20Handlers = true;\\n        ERC20AdapterLib.installEscrowRecord(inputs.to, newToken);\\n      }\\n    } else if (sig == IUniswapV2Router01.swapETHForExactTokens.selector) {\\n      UniswapV2AdapterLib.SwapETHForExactTokensInputs memory inputs = args.decodeSwapETHForExactTokensInputs();\\n      address WETH = getWETH(payload);\\n      (startToken, newToken) = inputs.path.validatePath(WETH);\\n      validateIsERC20Module(payload, newToken);\\n      if (inputs.to != address(this)) {\\n        payload.callData = inputs.changeRecipient(escrowWallet).encodeWithSelector();\\n        shouldTriggerERC20Handlers = true;\\n        ERC20AdapterLib.installEscrowRecord(inputs.to, newToken);\\n      }\\n    } else revert(\\\"unsupported contract call\\\");\\n    if (newToken != address(0x0)) {\\n      require(payload.liquidationSubmodule.delegateNotify(newToken.encodeLiquidationNotify()), \\\"liquidation module notification failure\\\");\\n    }\\n    require(startToken.approveForMaxIfNeeded(payload.to), \\\"failed to approve start token\\\");\\n    if (shouldTriggerERC20Handlers) proxyIsolate.triggerERC20Handlers(payload.moduleAddress);\\n    (bool success, bytes memory retval) = payload.to.call{ gas: gasleft(), value: payload.value }(payload.callData);\\n    ModuleLib.bubbleResult(success, retval);\\n  }\\n}\\n\",\"keccak256\":\"0xd0db3cc6117f6fbf10ca97a976f29f39894643f5df89663b896cf36ead6609cd\",\"license\":\"MIT\"},\"contracts/adapters/assets/uniswap-v2/UniswapV2AdapterLib.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { UniswapV2Adapter } from \\\"./UniswapV2Adapter.sol\\\";\\nimport { IUniswapV2Router01 } from \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\\\";\\nimport { BorrowProxyLib } from \\\"../../../BorrowProxyLib.sol\\\";\\nimport { ShifterBorrowProxyLib } from \\\"../../../ShifterBorrowProxyLib.sol\\\";\\nimport { Create2 } from \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\nimport { ModuleLib } from \\\"../../lib/ModuleLib.sol\\\";\\nimport { AddressSetLib } from \\\"../../../utils/AddressSetLib.sol\\\";\\n\\nlibrary UniswapV2AdapterLib {\\n  using BorrowProxyLib for *;\\n  using AddressSetLib for *;\\n  using ShifterBorrowProxyLib for *;\\n  bytes32 constant ETHER_FORWARDER_SALT = 0x3e8d8e49b9a35f50b96f6ba4b93e0fc6c1d66a2e1c04975ef848d7031c8158a4; // keccak(\\\"uniswap-adapter.ether-forwarder\\\")\\n  struct Isolate {\\n    uint256 liquidityMinimum;\\n    address erc20Module;\\n  }\\n  struct SwapExactTokensForTokensInputs {\\n    uint256 amountIn;\\n    uint256 amountOutMin;\\n    address[] path;\\n    address to;\\n    uint256 deadline;\\n  }\\n  function decodeSwapExactTokensForTokensInputs(bytes memory args) internal pure returns (SwapExactTokensForTokensInputs memory) {\\n    (uint256 amountIn, uint256 amountOutMin, address[] memory path, address to, uint256 deadline) = abi.decode(args, (uint256, uint256, address[], address, uint256));\\n    return SwapExactTokensForTokensInputs({\\n      amountIn: amountIn,\\n      amountOutMin: amountOutMin,\\n      path: path,\\n      to: to,\\n      deadline: deadline\\n    });\\n  }\\n  function changeRecipient(SwapExactTokensForTokensInputs memory inputs, address newRecipient) internal pure returns (SwapExactTokensForTokensInputs memory) {\\n    return SwapExactTokensForTokensInputs({\\n      amountIn: inputs.amountIn,\\n      amountOutMin: inputs.amountOutMin,\\n      path: inputs.path,\\n      to: newRecipient,\\n      deadline: inputs.deadline\\n    });\\n  }\\n  function encodeWithSelector(SwapExactTokensForTokensInputs memory inputs) internal pure returns (bytes memory callData) {\\n    callData = abi.encodeWithSelector(IUniswapV2Router01.swapExactTokensForTokens.selector, inputs.amountIn, inputs.amountOutMin, inputs.path, inputs.to, inputs.deadline);\\n  }\\n  struct SwapTokensForExactTokensInputs {\\n    uint256 amountOut;\\n    uint256 amountInMax;\\n    address[] path;\\n    address to;\\n    uint256 deadline;\\n  }\\n  function decodeSwapTokensForExactTokensInputs(bytes memory args) internal pure returns (SwapTokensForExactTokensInputs memory) {\\n    (uint256 amountOut, uint256 amountInMax, address[] memory path, address to, uint256 deadline) = abi.decode(args, (uint256, uint256, address[], address, uint256));\\n    return SwapTokensForExactTokensInputs({\\n      amountOut: amountOut,\\n      amountInMax: amountInMax,\\n      path: path,\\n      to: to,\\n      deadline: deadline\\n    });\\n  }\\n  function changeRecipient(SwapTokensForExactTokensInputs memory inputs, address newRecipient) internal pure returns (SwapTokensForExactTokensInputs memory) {\\n    return SwapTokensForExactTokensInputs({\\n      amountOut: inputs.amountOut,\\n      amountInMax: inputs.amountInMax,\\n      path: inputs.path,\\n      to: newRecipient,\\n      deadline: inputs.deadline\\n    });\\n  }\\n  function encodeWithSelector(SwapTokensForExactTokensInputs memory inputs) internal pure returns (bytes memory callData) {\\n    callData = abi.encodeWithSelector(IUniswapV2Router01.swapTokensForExactTokens.selector, inputs.amountOut, inputs.amountInMax, inputs.path, inputs.to, inputs.deadline);\\n  }\\n  struct SwapExactETHForTokensInputs {\\n    uint256 amountOutMin;\\n    address[] path;\\n    address to;\\n    uint256 deadline;\\n  }\\n  function decodeSwapExactETHForTokensInputs(bytes memory args) internal pure returns (SwapExactETHForTokensInputs memory) {\\n    (uint256 amountOutMin, address[] memory path, address to, uint256 deadline) = abi.decode(args, (uint256, address[], address, uint256));\\n    return SwapExactETHForTokensInputs({\\n      amountOutMin: amountOutMin,\\n      path: path,\\n      to: to,\\n      deadline: deadline\\n    });\\n  }\\n  function changeRecipient(SwapExactETHForTokensInputs memory inputs, address newRecipient) internal pure returns (SwapExactETHForTokensInputs memory) {\\n    return SwapExactETHForTokensInputs({\\n      amountOutMin: inputs.amountOutMin,\\n      path: inputs.path,\\n      to: newRecipient,\\n      deadline: inputs.deadline\\n    });\\n  }\\n  function encodeWithSelector(SwapExactETHForTokensInputs memory inputs) internal pure returns (bytes memory callData) {\\n    callData = abi.encodeWithSelector(IUniswapV2Router01.swapExactETHForTokens.selector, inputs.amountOutMin, inputs.path, inputs.to, inputs.deadline);\\n  }\\n  struct SwapTokensForExactETHInputs {\\n    uint256 amountOut;\\n    uint256 amountInMax;\\n    address[] path;\\n    address to;\\n    uint256 deadline;\\n  }\\n  function decodeSwapTokensForExactETHInputs(bytes memory args) internal pure returns (SwapTokensForExactETHInputs memory) {\\n    (uint256 amountOut, uint256 amountInMax, address[] memory path, address to, uint256 deadline) = abi.decode(args, (uint256, uint256, address[], address, uint256));\\n    return SwapTokensForExactETHInputs({\\n      amountOut: amountOut,\\n      amountInMax: amountInMax,\\n      path: path,\\n      to: to,\\n      deadline: deadline\\n    });\\n  }\\n  function changeRecipient(SwapTokensForExactETHInputs memory inputs, address newRecipient) internal pure returns (SwapTokensForExactETHInputs memory) {\\n    return SwapTokensForExactETHInputs({\\n      amountOut: inputs.amountOut,\\n      amountInMax: inputs.amountInMax,\\n      path: inputs.path,\\n      to: newRecipient,\\n      deadline: inputs.deadline\\n    });\\n  }\\n  function encodeWithSelector(SwapTokensForExactETHInputs memory inputs) internal pure returns (bytes memory callData) {\\n    callData = abi.encodeWithSelector(IUniswapV2Router01.swapTokensForExactETH.selector, inputs.amountOut, inputs.amountInMax, inputs.path, inputs.to, inputs.deadline);\\n  }\\n  struct SwapExactTokensForETHInputs {\\n    uint256 amountIn;\\n    uint256 amountOutMin;\\n    address[] path;\\n    address to;\\n    uint256 deadline;\\n  }\\n  function decodeSwapExactTokensForETHInputs(bytes memory args) internal pure returns (SwapExactTokensForETHInputs memory) {\\n    (uint256 amountIn, uint256 amountOutMin, address[] memory path, address to, uint256 deadline) = abi.decode(args, (uint256, uint256, address[], address, uint256));\\n    return SwapExactTokensForETHInputs({\\n      amountIn: amountIn,\\n      amountOutMin: amountOutMin,\\n      path: path,\\n      to: to,\\n      deadline: deadline\\n    });\\n  }\\n  function changeRecipient(SwapExactTokensForETHInputs memory inputs, address newRecipient) internal pure returns (SwapExactTokensForETHInputs memory) {\\n    return SwapExactTokensForETHInputs({\\n      amountIn: inputs.amountIn,\\n      amountOutMin: inputs.amountOutMin,\\n      path: inputs.path,\\n      to: newRecipient,\\n      deadline: inputs.deadline\\n    });\\n  }\\n  function encodeWithSelector(SwapExactTokensForETHInputs memory inputs) internal pure returns (bytes memory callData) {\\n    callData = abi.encodeWithSelector(IUniswapV2Router01.swapExactTokensForETH.selector, inputs.amountIn, inputs.amountOutMin, inputs.path, inputs.to, inputs.deadline);\\n  }\\n  struct SwapETHForExactTokensInputs {\\n    uint256 amountOut;\\n    address[] path;\\n    address to;\\n    uint256 deadline;\\n  }\\n  function decodeSwapETHForExactTokensInputs(bytes memory args) internal pure returns (SwapETHForExactTokensInputs memory) {\\n    (uint256 amountOut, address[] memory path, address to, uint256 deadline) = abi.decode(args, (uint256, address[], address, uint256));\\n    return SwapETHForExactTokensInputs({\\n      amountOut: amountOut,\\n      path: path,\\n      to: to,\\n      deadline: deadline\\n    });\\n  }\\n  function changeRecipient(SwapETHForExactTokensInputs memory inputs, address newRecipient) internal pure returns (SwapETHForExactTokensInputs memory) {\\n    return SwapETHForExactTokensInputs({\\n      amountOut: inputs.amountOut,\\n      path: inputs.path,\\n      to: newRecipient,\\n      deadline: inputs.deadline\\n    });\\n  }\\n  function encodeWithSelector(SwapETHForExactTokensInputs memory inputs) internal pure returns (bytes memory callData) {\\n    callData = abi.encodeWithSelector(IUniswapV2Router01.swapETHForExactTokens.selector, inputs.amountOut, inputs.path, inputs.to, inputs.deadline);\\n  }\\n  function computeIsolatePointer(address instance) public pure returns (uint256) {\\n    return uint256(keccak256(abi.encodePacked(\\\"isolate.uniswap-v2-adapter\\\", instance)));\\n  }\\n  function validatePath(address[] memory path, address WETH) internal pure returns (address begin, address destination) {\\n    if (path.length < 2) revert(\\\"path too short, must be 3 elements\\\");\\n    if (path.length > 3 || !(path[0] == WETH || path[1] == WETH)) revert(\\\"path must be 2 or 3 items and include WETH\\\");\\n    return (path[0], path[path.length - 1]);\\n  }\\n  function generatePathForToken(address startToken, address WETH, address token) internal pure returns (address[] memory path) {\\n    path = new address[](3);\\n    path[0] = startToken;\\n    path[1] = WETH;\\n    path[2] = token;\\n  }\\n  function getCastStorageType() internal pure returns (function (uint256) internal pure returns (Isolate storage) swap) {\\n    function (uint256) internal returns (uint256) cast = ModuleLib.cast;\\n    assembly {\\n      swap := cast\\n    }\\n  }\\n  function toIsolatePointer(uint256 key) internal pure returns (Isolate storage) {\\n    return getCastStorageType()(key);\\n  }\\n  function getIsolatePointer(address instance) internal pure returns (Isolate storage) {\\n    return toIsolatePointer(computeIsolatePointer(instance));\\n  }\\n  function getExternalIsolate(address payable moduleAddress) internal view returns (Isolate memory) {\\n    return UniswapV2Adapter(moduleAddress).getExternalIsolateHandler();\\n  }\\n  function encodeLiquidationNotify(address newToken) internal pure returns (bytes memory result) {\\n    result = abi.encode(newToken);\\n  }\\n  function triggerERC20Handlers(BorrowProxyLib.ProxyIsolate storage proxyIsolate, address moduleAddress) internal {\\n    Isolate memory isolate = UniswapV2Adapter(moduleAddress).getExternalIsolateHandler();\\n    proxyIsolate.repaymentSet.insert(isolate.erc20Module);\\n  }\\n}\\n\",\"keccak256\":\"0x094e3c7b9ffea2464f00f9e928530e4038020d55d52ac0d7ad7af214b9e1a21c\",\"license\":\"MIT\"},\"contracts/adapters/lib/AssetForwarder.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { TokenUtils } from \\\"../../utils/TokenUtils.sol\\\";\\n\\ncontract AssetForwarder {\\n  using TokenUtils for *;\\n  bool public locked;\\n  function lock() public {\\n    locked = true;\\n  }\\n  function forwardAsset(address payable target, address token) public payable {\\n    require(!locked);\\n    if (token != address(0x0)) require(token.sendToken(target, IERC20(token).balanceOf(address(this))), \\\"erc20 forward failure\\\");\\n    selfdestruct(target);\\n  }\\n}\\n\",\"keccak256\":\"0x45affa7770bfb273f439176f5189c686491db71a9be4ef390abf112c9ba4cf3f\",\"license\":\"MIT\"},\"contracts/adapters/lib/AssetForwarderLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { AssetForwarder } from \\\"./AssetForwarder.sol\\\";\\nimport { Create2 } from \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\nimport { FactoryLib } from \\\"../../FactoryLib.sol\\\";\\nimport { ShifterPool } from \\\"../../ShifterPool.sol\\\";\\n\\nlibrary AssetForwarderLib {\\n  bytes32 constant ASSET_FORWARDER_IMPLEMENTATION_SALT = 0x6b6f6b75258f8f4cdb6ef275682bc2be3e8b970e5e4417113bd1ea53622d907e; // keccak(\\\"asset-forwarder-implementation\\\")\\n  function GET_ASSET_FORWARDER_IMPLEMENTATION_SALT() internal pure returns (bytes32) {\\n    return ASSET_FORWARDER_IMPLEMENTATION_SALT;\\n  }\\n  function deployAssetForwarder() internal returns (address output) {\\n    output = Create2.deploy(0, ASSET_FORWARDER_IMPLEMENTATION_SALT, type(AssetForwarder).creationCode);\\n  }\\n  function deployAssetForwarderClone(address target, bytes32 salt) internal returns (address output) {\\n    output = FactoryLib.create2Clone(target, uint256(salt));\\n  }\\n  function deriveAssetForwarderAddress(address payable shifterPool, address from, bytes32 salt) internal view returns (address) {\\n    return FactoryLib.deriveInstanceAddress(shifterPool, ShifterPool(shifterPool).getAssetForwarderImplementationHandler(), keccak256(abi.encodePacked(GET_ASSET_FORWARDER_IMPLEMENTATION_SALT(), from, salt)));\\n  }\\n}\\n\",\"keccak256\":\"0xd34ee10bb6e0a76bad8a90786915836fa9f11c1ca46091ca3bd19a0e5a1b398b\",\"license\":\"MIT\"},\"contracts/adapters/lib/ModuleLib.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { SliceLib } from \\\"../../utils/SliceLib.sol\\\";\\n\\ninterface IModule {\\n  function handle(ModuleLib.AssetSubmodulePayload calldata) external payable;\\n}\\n\\nlibrary ModuleLib {\\n  address payable constant ETHER_ADDRESS = 0x0000000000000000000000000000000000000000;\\n  function GET_ETHER_ADDRESS() internal pure returns (address payable) {\\n    return ETHER_ADDRESS;\\n  }\\n  function cast(uint256 v) internal pure returns (uint256) {\\n    return v;\\n  }\\n  function splitPayload(bytes memory payload) internal pure returns (bytes4 sig, bytes memory args) {\\n    sig = bytes4(uint32(uint256(SliceLib.asWord(SliceLib.toSlice(payload, 0, 4)))));\\n    args = SliceLib.copy(SliceLib.toSlice(payload, 4));\\n  }\\n  struct AssetSubmodulePayload {\\n    address payable moduleAddress;\\n    address liquidationSubmodule;\\n    address repaymentSubmodule;\\n    address payable token;\\n    address payable txOrigin;\\n    address payable to;\\n    uint256 value;\\n    bytes callData;\\n  }\\n  function encodeWithSelector(AssetSubmodulePayload memory input) internal pure returns (bytes memory result) {\\n    result = abi.encodeWithSelector(IModule.handle.selector, input);\\n  }\\n  function bubbleResult(bool success, bytes memory retval) internal pure {\\n    assembly {\\n      if iszero(success) {\\n        revert(add(0x20, retval), mload(retval))\\n      }\\n      return(add(0x20, retval), mload(retval))\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x03885b4abdb3ce947222c3b8b8c6ab0ee3f34e9f4bcd6dea723c8eecb7de69d5\",\"license\":\"MIT\"},\"contracts/interfaces/IBorrowProxyController.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\ninterface IBorrowProxyController {\\n  function getProxyOwnerHandler() external returns (address);\\n  function validateProxyRecordHandler(bytes calldata) external returns (bool);\\n}\\n\",\"keccak256\":\"0x7b767728648d1fe8fff17648e5b8791b3939d6de13c27f6d7e12b14fbccca381\",\"license\":\"MIT\"},\"contracts/interfaces/IInitializationActionsReceiver.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { SandboxLib } from \\\"../utils/sandbox/SandboxLib.sol\\\";\\nimport { ShifterBorrowProxyLib } from \\\"../ShifterBorrowProxyLib.sol\\\";\\n\\ninterface IInitializationActionsReceiver {\\n  function receiveInitializationActions(ShifterBorrowProxyLib.InitializationAction[] calldata actions) external returns (SandboxLib.Context memory context);\\n}\\n\",\"keccak256\":\"0x3b99602cbca2e9a92feae53362b85b47541d1e47ea4e283a78c08001b152d8f1\",\"license\":\"MIT\"},\"contracts/interfaces/IModuleRegistryProvider.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { BorrowProxyLib } from \\\"../BorrowProxyLib.sol\\\";\\n\\ninterface IModuleRegistryProvider {\\n  function fetchModuleHandler(address to, bytes4 sig) external returns (BorrowProxyLib.Module memory);\\n}\\n\",\"keccak256\":\"0x792268c81b8385756e08f08699301caf506a887c2c899d069b25cfeb4341e1f6\",\"license\":\"MIT\"},\"contracts/interfaces/IShifter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\ninterface IShifter {\\n  function mint(bytes32 _pHash, uint256 _amount, bytes32 _nHash, bytes calldata _sig) external returns (uint256);\\n  function mintFee() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x26475c55e8f35728e04b0b61a5dbaca020f9ce02bbac1d02b0ddf2ff4fdcadf7\",\"license\":\"MIT\"},\"contracts/interfaces/IShifterERC20.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\ninterface IShifterERC20 {\\n  function fromUnderlying(uint256 amount) external returns (uint256);\\n}\\n  \\n\",\"keccak256\":\"0x7bcb210ac3d6e55d793b9f16c24defd8bd32337f94f9ae25bc49124f7efcdd09\",\"license\":\"MIT\"},\"contracts/interfaces/IShifterRegistry.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { IShifter } from \\\"./IShifter.sol\\\";\\n\\ninterface IShifterRegistry {\\n  function getGatewayByToken(address _tokenAddress) external view returns (IShifter);\\n}\\n\",\"keccak256\":\"0xd6100563bcc2fa8314d90fd99c87562bfa2742e688b7c0b37ddc1b2caccb2079\",\"license\":\"MIT\"},\"contracts/preprocessors/lib/PreprocessorLib.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { SandboxLib } from \\\"../../utils/sandbox/SandboxLib.sol\\\";\\nimport { ShifterBorrowProxyLib } from \\\"../../ShifterBorrowProxyLib.sol\\\";\\n\\nlibrary PreprocessorLib {\\n  function toContext(bytes memory input) internal pure returns (SandboxLib.ExecutionContext memory) {\\n    return SandboxLib.toContext(input);\\n  }\\n  function then(ShifterBorrowProxyLib.InitializationAction memory action, ShifterBorrowProxyLib.InitializationAction memory nextAction) internal pure returns (ShifterBorrowProxyLib.InitializationAction[] memory result) {\\n    result = new ShifterBorrowProxyLib.InitializationAction[](2);\\n    result[0] = action;\\n    result[1] = nextAction;\\n  }\\n  function getLastExecution(SandboxLib.Context memory context) internal pure returns (bool foundLast, SandboxLib.ProtectedExecution memory execution) {\\n    if (context.trace.length == 0) return (foundLast, execution);\\n    SandboxLib.ProtectedExecution[] memory lastBatch = context.trace[context.trace.length - 1];\\n    execution = lastBatch[lastBatch.length - 1];\\n  }\\n  function then(ShifterBorrowProxyLib.InitializationAction[] memory actions, ShifterBorrowProxyLib.InitializationAction[] memory nextActions) internal pure returns (ShifterBorrowProxyLib.InitializationAction[] memory result) {\\n    result = new ShifterBorrowProxyLib.InitializationAction[](actions.length + nextActions.length);\\n    uint256 i = 0;\\n    for (; i < actions.length; i++) {\\n      result[i] = actions[i];\\n    }\\n    for (uint256 j = 0; j < nextActions.length; j++) {\\n      result[i] = nextActions[j];\\n      i++;\\n    }\\n  }\\n  function then(ShifterBorrowProxyLib.InitializationAction[] memory actions, ShifterBorrowProxyLib.InitializationAction memory nextAction) internal pure returns (ShifterBorrowProxyLib.InitializationAction[] memory result) {\\n    result = then(actions, toList(nextAction));\\n  }\\n  function toList(ShifterBorrowProxyLib.InitializationAction memory input) internal pure returns (ShifterBorrowProxyLib.InitializationAction[] memory result) {\\n    result = new ShifterBorrowProxyLib.InitializationAction[](1);\\n    result[0] = input;\\n  }\\n  function sendTransaction(address to, bytes memory txData) internal pure returns (ShifterBorrowProxyLib.InitializationAction[] memory result) {\\n    return toList(ShifterBorrowProxyLib.InitializationAction({\\n      to: to,\\n      txData: txData\\n    }));\\n  }\\n}\\n\",\"keccak256\":\"0x4a68c135a40b0ff83c289d6a4e292bd0cbdc292b3e420c5f92958c16add43121\",\"license\":\"MIT\"},\"contracts/utils/AddressSetLib.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nlibrary AddressSetLib {\\n  struct AddressSet {\\n    mapping (address => bool) uniq;\\n    address[] set;\\n  }\\n  function insert(AddressSet storage addressSet, address item) internal {\\n    if (addressSet.uniq[item]) return;\\n    addressSet.set.push(item);\\n  }\\n  function get(AddressSet storage addressSet, uint256 i) internal view returns (address) {\\n    return addressSet.set[i];\\n  }\\n  function size(AddressSet storage addressSet) internal view returns (uint256) {\\n    return addressSet.set.length;\\n  }\\n}\\n\",\"keccak256\":\"0x5b5e060c2825541a6bd9372e33adba3ab8451642d022922184f51ab87cf33fce\",\"license\":\"MIT\"},\"contracts/utils/ExtLib.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nlibrary ExtLib {\\n  function getExtCodeHash(address target) internal view returns (bytes32 result) {\\n    assembly {\\n      result := extcodehash(target)\\n    }\\n  }\\n  function isContract(address target) internal view returns (bool result) {\\n    assembly {\\n      result := iszero(iszero(extcodesize(target)))\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0xc7de2388e172afde1e93560f451bd6215f411a7ed51cdb750cbc17617173cd57\",\"license\":\"MIT\"},\"contracts/utils/MemcpyLib.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nlibrary MemcpyLib {\\n  function memcpy(bytes32 dest, bytes32 src, uint256 len) internal pure {\\n    assembly {\\n      for {} iszero(lt(len, 0x20)) { len := sub(len, 0x20) } {\\n        mstore(dest, mload(src))\\n        dest := add(dest, 0x20)\\n        src := add(src, 0x20)\\n      }\\n      let mask := sub(shl(mul(sub(32, len), 8), 1), 1)\\n      mstore(dest, or(and(mload(src), not(mask)), and(mload(dest), mask)))\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x6692972a7b1f397575ce10ab8652b92337ae9b30fda75c7648acb6c309d7dbf0\",\"license\":\"MIT\"},\"contracts/utils/RevertCaptureLib.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { SliceLib } from \\\"./SliceLib.sol\\\";\\n\\nlibrary RevertCaptureLib {\\n  using SliceLib for *;\\n  uint32 constant REVERT_WITH_REASON_MAGIC = 0x08c379a0; // keccak256(\\\"Error(string)\\\")\\n  function decodeString(bytes memory input) internal pure returns (string memory retval) {\\n    (retval) = abi.decode(input, (string));\\n  }\\n  function decodeError(bytes memory buffer) internal pure returns (string memory) {\\n    if (buffer.length == 0) return \\\"captured empty revert buffer\\\";\\n    if (uint32(uint256(bytes32(buffer.toSlice(0, 4).asWord()))) != REVERT_WITH_REASON_MAGIC) return \\\"captured a revert error, but it doesn't conform to the standard\\\";\\n    bytes memory revertMessageEncoded = buffer.toSlice(4).copy();\\n    if (revertMessageEncoded.length == 0) return \\\"captured empty revert message\\\";\\n    (string memory revertMessage) = decodeString(revertMessageEncoded);\\n    return revertMessage;\\n  }\\n}\\n\",\"keccak256\":\"0x03a939369019394c9ddb4e79e0a4b90c4f5d8e398ff5db501c9f9d4ee68997c5\",\"license\":\"MIT\"},\"contracts/utils/SliceLib.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { MemcpyLib } from \\\"./MemcpyLib.sol\\\";\\n\\nlibrary SliceLib {\\n  struct Slice {\\n    uint256 data;\\n    uint256 length;\\n    uint256 offset;\\n  }\\n  function toPtr(bytes memory input, uint256 offset) internal pure returns (uint256 data) {\\n    assembly {\\n      data := add(input, add(offset, 0x20))\\n    }\\n  }\\n  function toSlice(bytes memory input, uint256 offset, uint256 length) internal pure returns (Slice memory retval) {\\n    retval.data = toPtr(input, offset);\\n    retval.length = length;\\n    retval.offset = offset;\\n  }\\n  function toSlice(bytes memory input) internal pure returns (Slice memory) {\\n    return toSlice(input, 0);\\n  }\\n  function toSlice(bytes memory input, uint256 offset) internal pure returns (Slice memory) {\\n    if (input.length < offset) offset = input.length;\\n    return toSlice(input, offset, input.length - offset);\\n  }\\n  function toSlice(Slice memory input, uint256 offset, uint256 length) internal pure returns (Slice memory) {\\n    return Slice({\\n      data: input.data + offset,\\n      offset: input.offset + offset,\\n      length: length\\n    });\\n  }\\n  function toSlice(Slice memory input, uint256 offset) internal pure returns (Slice memory) {\\n    return toSlice(input, offset, input.length - offset);\\n  }\\n  function toSlice(Slice memory input) internal pure returns (Slice memory) {\\n    return toSlice(input, 0);\\n  }\\n  function maskLastByteOfWordAt(uint256 data) internal pure returns (uint8 lastByte) {\\n    assembly {\\n      lastByte := and(mload(data), 0xff)\\n    }\\n  }\\n  function get(Slice memory slice, uint256 index) internal pure returns (bytes1 result) {\\n    return bytes1(maskLastByteOfWordAt(slice.data - 0x1f + index));\\n  }\\n  function setByteAt(uint256 ptr, uint8 value) internal pure {\\n    assembly {\\n      mstore8(ptr, value)\\n    }\\n  }\\n  function set(Slice memory slice, uint256 index, uint8 value) internal pure {\\n    setByteAt(slice.data + index, value);\\n  }\\n  function wordAt(uint256 ptr, uint256 length) internal pure returns (bytes32 word) {\\n    assembly {\\n      let mask := sub(shl(mul(length, 0x8), 0x1), 0x1)\\n      word := and(mload(sub(ptr, sub(0x20, length))), mask)\\n    }\\n  }\\n  function asWord(Slice memory slice) internal pure returns (bytes32 word) {\\n    uint256 data = slice.data;\\n    uint256 length = slice.length;\\n    return wordAt(data, length);\\n  }\\n  function toDataStart(bytes memory input) internal pure returns (bytes32 start) {\\n    assembly {\\n      start := add(input, 0x20)\\n    }\\n  }\\n  function copy(Slice memory slice) internal pure returns (bytes memory retval) {\\n    uint256 length = slice.length;\\n    retval = new bytes(length);\\n    bytes32 src = bytes32(slice.data);\\n    bytes32 dest = toDataStart(retval);\\n    MemcpyLib.memcpy(dest, src, length);\\n  }\\n  function keccakAt(uint256 data, uint256 length) internal pure returns (bytes32 result) {\\n    assembly {\\n      result := keccak256(data, length)\\n    }\\n  }\\n  function toKeccak(Slice memory slice) internal pure returns (bytes32 result) {\\n    return keccakAt(slice.data, slice.length);\\n  }\\n}\\n\",\"keccak256\":\"0xde40e25d2efd85a714714a080b7d62b3633effa0613d4ca7831a5abbf70180d3\",\"license\":\"MIT\"},\"contracts/utils/StringLib.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nlibrary StringLib {\\n    /// @notice Convert a uint value to its decimal string representation\\n    // solium-disable-next-line security/no-assign-params\\n    function toString(uint256 _i) internal pure returns (string memory) {\\n        if (_i == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 j = _i;\\n        uint256 len;\\n        while (j != 0) {\\n            len++;\\n            j /= 10;\\n        }\\n        bytes memory bstr = new bytes(len);\\n        uint256 k = len - 1;\\n        while (_i != 0) {\\n            bstr[k--] = bytes1(uint8(48 + (_i % 10)));\\n            _i /= 10;\\n        }\\n        return string(bstr);\\n    }\\n\\n    /// @notice Convert a bytes32 value to its hex string representation\\n    function toString(bytes32 _value) internal pure returns (string memory) {\\n        bytes memory alphabet = \\\"0123456789abcdef\\\";\\n\\n        bytes memory str = new bytes(32 * 2 + 2);\\n        str[0] = \\\"0\\\";\\n        str[1] = \\\"x\\\";\\n        for (uint256 i = 0; i < 32; i++) {\\n            str[2 + i * 2] = alphabet[uint256(uint8(_value[i] >> 4))];\\n            str[3 + i * 2] = alphabet[uint256(uint8(_value[i] & 0x0f))];\\n        }\\n        return string(str);\\n    }\\n\\n    /// @notice Convert an address to its hex string representation\\n    function toString(address _addr) internal pure returns (string memory) {\\n        bytes32 value = bytes32(uint256(_addr));\\n        bytes memory alphabet = \\\"0123456789abcdef\\\";\\n\\n        bytes memory str = new bytes(20 * 2 + 2);\\n        str[0] = \\\"0\\\";\\n        str[1] = \\\"x\\\";\\n        for (uint256 i = 0; i < 20; i++) {\\n            str[2 + i * 2] = alphabet[uint256(uint8(value[i + 12] >> 4))];\\n            str[3 + i * 2] = alphabet[uint256(uint8(value[i + 12] & 0x0f))];\\n        }\\n        return string(str);\\n    }\\n    function toString(bytes memory input) internal pure returns (string memory) {\\n      return string(input);\\n    }\\n}\\n\",\"keccak256\":\"0xe9996ac71f9b093c2857d86d1480d2698c5ad5e37dc7a6d0f425e53721c51091\",\"license\":\"MIT\"},\"contracts/utils/TokenUtils.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nlibrary TokenUtils {\\n  function encodeTransfer(address target, uint256 amount) internal pure returns (bytes memory retval) {\\n    retval = abi.encodeWithSelector(IERC20.transfer.selector, target, amount);\\n  }\\n  function sendToken(address token, address target, uint256 amount) internal returns (bool) {\\n    (bool success,) = token.call(encodeTransfer(target, amount));\\n    return success;\\n  }\\n  function encodeTransferFrom(address from, address to, uint256 amount) internal pure returns (bytes memory retval) {\\n    retval = abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, amount);\\n  }\\n  function transferTokenFrom(address token, address from, address to, uint256 amount) internal returns (bool) {\\n    (bool success,) = token.call(encodeTransferFrom(from, to, amount));\\n    return success;\\n  }\\n  function encodeApproval(address target, uint256 amount) internal pure returns (bytes memory retval) {\\n    retval = abi.encodeWithSelector(IERC20.approve.selector, target, amount);\\n  }\\n  function approveToken(address token, address target, uint256 amount) internal returns (bool) {\\n    (bool success,) = token.call(encodeApproval(target, amount));\\n    return success;\\n  }\\n  uint256 constant THRESHOLD = 0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\n  uint256 constant MAX_UINT256 = 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\n  function approveForMaxIfNeeded(address token, address target) internal returns (bool) {\\n    uint256 approved = getApproved(token, address(this), target);\\n    if (approved > THRESHOLD) return true;\\n    if (approved != 0 && !approveToken(token, address(this), 0)) return false;\\n    return approveToken(token, target, MAX_UINT256);\\n  }\\n  function encodeAllowance(address source, address target) internal pure returns (bytes memory retval) {\\n    retval = abi.encodeWithSelector(IERC20.allowance.selector, source, target);\\n  }\\n  function decodeUint(bytes memory input) internal pure returns (uint256 retval) {\\n    (retval) = abi.decode(input, (uint256));\\n  }\\n  function getApproved(address token, address source, address target) internal returns (uint256) {\\n    (bool success, bytes memory retval) = token.call(encodeAllowance(source, target));\\n    if (!success || retval.length != 0x20) return 0x1;\\n    return decodeUint(retval);\\n  }\\n}\\n\",\"keccak256\":\"0x4fbca09a038a8272ad9e8cf05c818c376c27720e37c8924e846966f0f9d8016c\",\"license\":\"MIT\"},\"contracts/utils/ViewExecutor.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\ncontract ViewExecutor {\\n  function encodeExecuteQuery(address viewLogic, bytes memory payload) internal pure returns (bytes memory retval) {\\n    retval = abi.encodeWithSignature(\\\"_executeQuery(address,bytes)\\\", viewLogic, payload);\\n  }\\n  function query(address viewLogic, bytes memory payload) public view returns (bytes memory) {\\n    (bool success, bytes memory response) = viewLogic.staticcall(encodeExecuteQuery(viewLogic, payload));\\n    require(success, string(response));\\n    return response;\\n  }\\n  function _executeQuery(address delegateTo, bytes memory callData) public returns (bytes memory) {\\n    require(msg.sender == address(this), \\\"unauthorized view layer delegation\\\");\\n    (bool success, bytes memory retval) = delegateTo.delegatecall(callData);\\n    require(success);\\n    return retval;\\n  }\\n}\\n\",\"keccak256\":\"0x19ac4d69df99b10bf8672557f20d1ce5dd0306766baccc249890e51278652e68\",\"license\":\"MIT\"},\"contracts/utils/sandbox/ISafeView.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\ninterface ISafeView {\\n  function execute(bytes calldata) external;\\n  function _executeSafeView(bytes calldata, bytes calldata) external;\\n}\\n\",\"keccak256\":\"0x5c6a466fb34671be27998d54ec8b11c5e9320fcd680ecd6c1363004bf0bca0f4\",\"license\":\"MIT\"},\"contracts/utils/sandbox/SafeViewExecutor.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { SafeViewLib } from \\\"./SafeViewLib.sol\\\";\\nimport { Create2 } from \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\n\\ncontract SafeViewExecutor {\\n  using SafeViewLib for *;\\n  bytes32 constant STEALTH_VIEW_DEPLOY_SALT = 0xad53495153c7c363e98a26920ec679e0e687636458f6908c91cf6deadb190801;\\n  function _executeSafeView(bytes memory creationCode, bytes memory context) public {\\n    address viewLayer = Create2.deploy(0, SafeViewLib.GET_STEALTH_VIEW_DEPLOY_SALT(), creationCode);\\n    bytes memory result = viewLayer.executeLogic(context).encodeResult();\\n    result.revertWithData();\\n  }\\n  function query(bytes memory creationCode, bytes memory context) public returns (SafeViewLib.SafeViewResult memory) {\\n    return creationCode.safeView(context);\\n  }\\n}\\n\",\"keccak256\":\"0xd51efe5b10a6960c509df5ed3bfefc1605c98643f4c733687d60af25092a5fb7\",\"license\":\"MIT\"},\"contracts/utils/sandbox/SafeViewLib.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { ISafeView } from \\\"./ISafeView.sol\\\";\\nimport { Create2 } from \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\n\\nlibrary SafeViewLib {\\n  struct SafeViewResult {\\n    bool success;\\n    bytes data;\\n  }\\n  function executeLogic(address viewLayer, bytes memory context) internal returns (SafeViewResult memory) {\\n    (bool success, bytes memory retval) = viewLayer.delegatecall(encodeExecute(context));\\n    return SafeViewResult({\\n      success: success,\\n      data: retval\\n    });\\n  }\\n  function encodeResult(SafeViewResult memory input) internal pure returns (bytes memory retval) {\\n    retval = abi.encode(input);\\n  }\\n  function revertWithData(bytes memory input) internal pure {\\n    assembly {\\n      revert(add(input, 0x20), mload(input))\\n    }\\n  }\\n  function decodeViewResult(bytes memory data) internal pure returns (SafeViewResult memory result) {\\n     (result) = abi.decode(data, (SafeViewResult));\\n   }\\n   function encodeExecuteSafeView(bytes memory creationCode, bytes memory context) internal pure returns (bytes memory retval) {\\n     retval = abi.encodeWithSelector(ISafeView._executeSafeView.selector, creationCode, context);\\n   }\\n   function encodeExecute(bytes memory context) internal pure returns (bytes memory retval) {\\n     retval = abi.encodeWithSelector(ISafeView.execute.selector, context);\\n   }\\n  function safeView(bytes memory creationCode, bytes memory context) internal returns (SafeViewLib.SafeViewResult memory) {\\n    (/* bool success */, bytes memory retval) = address(this).call(encodeExecuteSafeView(creationCode, context));\\n    return decodeViewResult(retval);\\n  }\\n  bytes32 constant STEALTH_VIEW_DEPLOY_SALT = 0xad53495153c7c363e98a26920ec679e0e687636458f6908c91cf6deadb190801;\\n  function GET_STEALTH_VIEW_DEPLOY_SALT() internal pure returns (bytes32) {\\n    return STEALTH_VIEW_DEPLOY_SALT;\\n  }\\n  function deriveViewAddress(bytes memory creationCode) internal view returns (address) {\\n    return Create2.computeAddress(STEALTH_VIEW_DEPLOY_SALT, keccak256(creationCode));\\n  }\\n}\\n\",\"keccak256\":\"0xa274f8262ba1e34d13f58f0bc29f12bdc43d19b7c8c3dc3b259566faed3a40ff\",\"license\":\"MIT\"},\"contracts/utils/sandbox/SandboxLib.sol\":{\"content\":\"pragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport { SliceLib } from \\\"../SliceLib.sol\\\";\\nimport { SafeViewLib } from \\\"./SafeViewLib.sol\\\";\\nimport { BorrowProxy } from \\\"../../BorrowProxy.sol\\\";\\nimport { ShifterBorrowProxyLib } from \\\"../../ShifterBorrowProxyLib.sol\\\";\\nimport { RevertCaptureLib } from \\\"../../utils/RevertCaptureLib.sol\\\";\\nimport { PreprocessorLib } from \\\"../../preprocessors/lib/PreprocessorLib.sol\\\";\\nimport { StringLib } from \\\"../../utils/StringLib.sol\\\";\\n\\nlibrary SandboxLib {\\n  using SafeViewLib for *;\\n  using SliceLib for *;\\n  using StringLib for *;\\n  using PreprocessorLib for *;\\n  struct ProtectedExecution {\\n    address to;\\n    bytes txData;\\n    bool success;\\n    bytes returnData;\\n  }\\n  function applyExecutionResult(ProtectedExecution[][] memory trace, uint256 index, ShifterBorrowProxyLib.InitializationAction[] memory preprocessed) internal pure returns (bool) {\\n    ProtectedExecution[] memory execution = new ProtectedExecution[](preprocessed.length);\\n    for (uint256 i = 0; i < execution.length; i++) {\\n      execution[i].txData = preprocessed[i].txData;\\n      execution[i].to = preprocessed[i].to;\\n    }\\n    trace[index] = execution;\\n    return execution.length != 0;\\n  }\\n  struct Context {\\n    address preprocessorAddress;\\n    ProtectedExecution[][] trace;\\n  }\\n  function encodeContext(ExecutionContext memory input) internal pure returns (bytes memory context) {\\n    context = abi.encode(input);\\n  }\\n  function toContext(bytes memory input) internal pure returns (ExecutionContext memory context) {\\n    (context) = abi.decode(input, (ExecutionContext));\\n  }\\n  function _write(ProtectedExecution[][] memory trace, uint256 newSize) internal pure {\\n    assembly {\\n      mstore(trace, newSize)\\n    }\\n  }\\n  function _restrict(Context memory context) internal pure {\\n    _write(context.trace, 0);\\n  }\\n  function _grow(Context memory context) internal pure {\\n    ProtectedExecution[][] memory trace = context.trace;\\n    uint256 newSize = trace.length;\\n    _write(trace, newSize + 1);\\n  }\\n  function toInitializationActions(bytes memory input) internal pure returns (ShifterBorrowProxyLib.InitializationAction[] memory action) {\\n    (action) = abi.decode(input, (ShifterBorrowProxyLib.InitializationAction[]));\\n  }\\n  function encodeInitializationActions(ShifterBorrowProxyLib.InitializationAction[] memory input) internal pure returns (bytes memory result) {\\n    result = abi.encode(input);\\n  }\\n  function _shrink(Context memory context) internal pure {\\n    _write(context.trace, context.trace.length - 1);\\n  }\\n  function encodeProxyCall(ProtectedExecution memory execution) internal pure returns (bytes memory retval) {\\n    retval = abi.encodeWithSelector(BorrowProxy.proxy.selector, execution.to, 0, execution.txData);\\n  }\\n  function toFlat(ProtectedExecution[][] memory execution) internal pure returns (ProtectedExecution[] memory trace) {\\n    uint256 total = 0;\\n    for (uint256 i = 0; i < execution.length; i++) {\\n      total += execution[i].length;\\n    }\\n    trace = new ProtectedExecution[](total);\\n    uint256 seen = 0;\\n    for (uint256 i = 0; i < execution.length; i++) {\\n      for (uint256 j = 0; j < execution[i].length; j++) {\\n        trace[seen] = execution[i][j];\\n      }\\n    }\\n  }\\n  function getNewContext(ShifterBorrowProxyLib.InitializationAction[] memory actions) internal pure returns (Context memory context) {\\n    ProtectedExecution[][] memory trace = new ProtectedExecution[][](actions.length);\\n    for (uint256 i = 0; i < actions.length; i++) {\\n      trace[i] = new ProtectedExecution[](1);\\n      trace[i][0].to = actions[i].to;\\n      trace[i][0].txData = actions[i].txData;\\n    }\\n    context = Context({\\n      trace: trace,\\n      preprocessorAddress: address(0)\\n    });\\n  }\\n  struct ExecutionContext {\\n    ProtectedExecution last;\\n    address preprocessorAddress;\\n  }\\n  function executeSafeView(bytes memory creationCode, uint256 index, Context memory context) internal returns (SafeViewLib.SafeViewResult memory result) {\\n    ExecutionContext memory executionContext;\\n    executionContext.preprocessorAddress = context.preprocessorAddress;\\n    if (index != 0) {\\n      ProtectedExecution[] memory lastBatch = context.trace[index];\\n      if (lastBatch.length != 0) executionContext.last = lastBatch[lastBatch.length - 1];\\n    }\\n    result = creationCode.safeView(encodeContext(executionContext));\\n  }\\n  function processActions(ShifterBorrowProxyLib.InitializationAction[] memory actions) internal returns (ProtectedExecution[] memory trace) {\\n    Context memory context = getNewContext(actions);\\n    for (uint256 i = 0; i < actions.length; i++) {\\n      ProtectedExecution[] memory execution = context.trace[i];\\n      if (execution[0].to == address(0x0)) {\\n        context.preprocessorAddress = execution[0].txData.deriveViewAddress();\\n        SafeViewLib.SafeViewResult memory safeViewResult = executeSafeView(execution[0].txData, i, context);\\n        execution[0].txData = new bytes(0x0);\\n        if (safeViewResult.success) {\\n          if (!applyExecutionResult(context.trace, i, toInitializationActions(safeViewResult.data))) break;\\n        } else {\\n          execution[0].returnData = safeViewResult.data;\\n          execution[0].success = safeViewResult.success;\\n// for debugging\\n          bytes memory data = execution[0].returnData;\\n          assembly {\\n            revert(add(data, 0x20), mload(data))\\n          }\\n// end\\n          continue;\\n        }\\n      }\\n      execution = context.trace[i];\\n      for (uint256 j = 0; j < execution.length; j++) {\\n        (bool success, bytes memory returnData) = address(this).call(encodeProxyCall(execution[j]));\\n        execution[j].success = success;\\n// for debugging\\n        if (!execution[j].success) {\\n          assembly {\\n            revert(add(0x20, returnData), mload(returnData))\\n          }\\n        }\\n// end\\n        execution[j].returnData = returnData;\\n      }\\n    }\\n    return toFlat(context.trace);\\n  }\\n}\\n\",\"keccak256\":\"0xd33735411d05231e29ecb682b11fb8612c308b90d1eabccc97951f54c8290b87\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60806040523480156200001157600080fd5b5060405162001e1d38038062001e1d833981016040819052620000349162000108565b60006200004c306200007560201b6200052e1760201c565b60010180546001600160a01b0319166001600160a01b0393909316929092179091555062000176565b60006200009e6200008f836001600160e01b03620000a416565b6001600160e01b03620000d716565b92915050565b600081604051602001620000b9919062000138565b60408051601f19818403018152919052805160209091012092915050565b60006200009e82620000f16001600160e01b03620000f616565b60201c565b620005476200010560201b1790565b90565b6000602082840312156200011a578081fd5b81516001600160a01b038116811462000131578182fd5b9392505050565b7f69736f6c6174652e756e69737761702d76322d61646170746572000000000000815260609190911b6001600160601b031916601a820152602e0190565b611c9780620001866000396000f3fe6080604052600436106100295760003560e01c80633c52e5a11461002e578063966ff7a814610043575b600080fd5b61004161003c36600461157c565b61006e565b005b34801561004f57600080fd5b506100586104f6565b6040516100659190611b61565b60405180910390f35b6000606061007f8360e0015161054a565b909250905060008061009081610582565b90506000806001600160e01b031986166338ed173960e01b141561013e576100b66113c2565b6100bf866105a4565b905060006100cc89610602565b60408301519091506100e4908263ffffffff61067916565b945092506100f28985610759565b5060608201516001600160a01b031630146101375761011f61011a838763ffffffff61083316565b610883565b60e08a015260608201516001965061013790856108f2565b50506103c0565b6001600160e01b03198616634401edf760e11b14156101c85761015f6113c2565b610168866105a4565b9050600061017589610602565b604083015190915061018d908263ffffffff61067916565b9450925061019b8985610759565b5060608201516001600160a01b031630146101375761011f6101c3838763ffffffff61083316565b610964565b6001600160e01b03198616637ff36ab560e01b141561026a576101e96113fa565b6101f28661099b565b905060006101ff89610602565b6020830151909150610217908263ffffffff61067916565b945092506102258985610759565b5060408201516001600160a01b031630146101375761025261024d838763ffffffff6109f516565b610a35565b60e08a015260408201516001965061013790856108f2565b6001600160e01b03198616632512eca560e11b141561028b576101e96113fa565b6001600160e01b031986166318cbafe560e01b1415610315576102ac6113c2565b6102b5866105a4565b905060006102c289610602565b60408301519091506102da908263ffffffff61067916565b945092506102e88985610759565b5060608201516001600160a01b031630146101375761011f610310838763ffffffff61083316565b610a66565b6001600160e01b0319861663fb3bdb4160e01b141561039f576103366113fa565b61033f8661099b565b9050600061034c89610602565b6020830151909150610364908263ffffffff61067916565b945092506103728985610759565b5060408201516001600160a01b031630146101375761025261039a838763ffffffff6109f516565b610a9d565b60405162461bcd60e51b81526004016103b790611a1d565b60405180910390fd5b6001600160a01b0382161561041a576103fe6103e4836001600160a01b0316610ace565b60208901516001600160a01b03169063ffffffff610af716565b61041a5760405162461bcd60e51b81526004016103b790611ae3565b60a0870151610439906001600160a01b0383169063ffffffff610b6616565b6104555760405162461bcd60e51b81526004016103b790611b2a565b831561046f57865161046f9060009063ffffffff610bd016565b600060608860a001516001600160a01b03165a8a60c001518b60e0015160405161049991906118ae565b600060405180830381858888f193505050503d80600081146104d7576040519150601f19603f3d011682016040523d82523d6000602084013e6104dc565b606091505b50915091506104eb8282610c69565b505050505050505050565b6104fe61142b565b6105073061052e565b60408051808201909152815481526001909101546001600160a01b03166020820152905090565b600061054161053c83610c7e565b610caf565b92915050565b90565b6000606061056361055e8460006004610cc5565b610cee565b60e01b915061057b610576846004610d03565b610d27565b9050915091565b60008061058d610d97565b805490915061059d908490610da9565b9392505050565b6105ac6113c2565b6000806060600080868060200190518101906105c8919061177b565b6040805160a0810182529586526020860194909452928401919091526001600160a01b031660608301526080820152979650505050505050565b60008160a001516001600160a01b031663ad5c46486040518163ffffffff1660e01b815260040160206040518083038186803b15801561064157600080fd5b505afa158015610655573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105419190611560565b60008060028451101561069e5760405162461bcd60e51b81526004016103b790611aa1565b6003845111806107045750826001600160a01b0316846000815181106106c057fe5b60200260200101516001600160a01b031614806107025750826001600160a01b0316846001815181106106ef57fe5b60200260200101516001600160a01b0316145b155b156107215760405162461bcd60e51b81526004016103b7906119d3565b8360008151811061072e57fe5b60200260200101518460018651038151811061074657fe5b6020026020010151915091509250929050565b600061076361142b565b835161076e90610e6c565b6020810151600054604051630220891b60e51b81529293506001600160a01b03918216929116906344112360906107b290879063a9059cbb60e01b90600401611960565b60806040518083038186803b1580156107ca57600080fd5b505afa1580156107de573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108029190611698565b602001516001600160a01b03161461082c5760405162461bcd60e51b81526004016103b790611a54565b5092915050565b61083b6113c2565b6040518060a00160405280846000015181526020018460200151815260200184604001518152602001836001600160a01b031681526020018460800151815250905092915050565b60606338ed173960e01b826000015183602001518460400151856060015186608001516040516024016108ba959493929190611bb6565b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b03199093169290921790915292915050565b60006108fc610d97565b604080518082019091526001600160a01b03948516815292841660208085019182528254600181810185556000948552919093209451600290930290940180549286166001600160a01b03199384161781559051930180549390941692169190911790915550565b6060638803dbee60e01b826000015183602001518460400151856060015186608001516040516024016108ba959493929190611bb6565b6109a36113fa565b60006060600080858060200190518101906109be919061171c565b6040805160808101825294855260208501939093526001600160a01b03909116918301919091526060820152945050505050919050565b6109fd6113fa565b506040805160808101825283518152602080850151908201526001600160a01b03909216908201526060918201519181019190915290565b6060637ff36ab560e01b82600001518360200151846040015185606001516040516024016108ba9493929190611b81565b60606318cbafe560e01b826000015183602001518460400151856060015186608001516040516024016108ba959493929190611bb6565b606063fb3bdb4160e01b82600001518360200151846040015185606001516040516024016108ba9493929190611b81565b606081604051602001610ae19190611932565b6040516020818303038152906040529050919050565b600080836001600160a01b0316610b0e8585610ee4565b604051610b1b91906118ae565b600060405180830381855af49150503d8060008114610b56576040519150601f19603f3d011682016040523d82523d6000602084013e610b5b565b606091505b509095945050505050565b600080610b74843085610f2a565b90506001600160fe1b03811115610b8f576001915050610541565b8015801590610ba75750610ba584306000610fc9565b155b15610bb6576000915050610541565b610bc884846001600160ff1b03610fc9565b949350505050565b610bd861142b565b816001600160a01b031663966ff7a86040518163ffffffff1660e01b8152600401604080518083038186803b158015610c1057600080fd5b505afa158015610c24573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c48919061165f565b9050610c6481602001518460090161103b90919063ffffffff16565b505050565b81610c7657805181602001fd5b805181602001f35b600081604051602001610c9191906118ca565b60408051601f19818403018152919052805160209091012092915050565b600061054182610cbd611095565b63ffffffff16565b610ccd611442565b610cd7848461109b565b815260208101919091526040810191909152919050565b8051602082015160009190610bc882826110a2565b610d0b611442565b8183511015610d1957825191505b61059d838384865103610cc5565b60208101516060908067ffffffffffffffff81118015610d4657600080fd5b506040519080825280601f01601f191660200182016040528015610d71576020820181803683370190505b5083519092506000610d82846110bf565b9050610d8f8183856110c5565b505050919050565b6000610da461053c611103565b905090565b8154604080516332dd41bd60e11b8152905160009261059d926001600160a01b039091169182916365ba837a916004808301926020929190829003018186803b158015610df557600080fd5b505afa158015610e09573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e2d9190611560565b610e3561111f565b30610e3f87611143565b604051602001610e519392919061188b565b60405160208183030381529060405280519060200120611173565b610e7461142b565b816001600160a01b031663966ff7a86040518163ffffffff1660e01b8152600401604080518083038186803b158015610eac57600080fd5b505afa158015610ec0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610541919061165f565b60608282604051602401610ef9929190611983565b60408051601f198184030181529190526020810180516001600160e01b0316633e87f4a360e21b1790529392505050565b6000806060856001600160a01b0316610f438686611190565b604051610f5091906118ae565b6000604051808303816000865af19150503d8060008114610f8d576040519150601f19603f3d011682016040523d82523d6000602084013e610f92565b606091505b5091509150811580610fa657508051602014155b15610fb65760019250505061059d565b610fbf816111e6565b9695505050505050565b600080846001600160a01b0316610fe085856111fc565b604051610fed91906118ae565b6000604051808303816000865af19150503d806000811461102a576040519150601f19603f3d011682016040523d82523d6000602084013e61102f565b606091505b50909695505050505050565b6001600160a01b03811660009081526020839052604090205460ff161561106157611091565b6001828101805491820181556000908152602090200180546001600160a01b0319166001600160a01b0383161790555b5050565b61054790565b0160200190565b6000600180600884021b0380836020038503511691505092915050565b60200190565b5b602081106110e5578151835260209283019290910190601f19016110c6565b600180600883602003021b0380845116811984511617845250505050565b600060405161111190611908565b604051908190039020905090565b7f6b6f6b75258f8f4cdb6ef275682bc2be3e8b970e5e4417113bd1ea53622d907e90565b6000816040516020016111569190611929565b604051602081830303815290604052805190602001209050919050565b6000610bc8826111838686611219565b8051906020012086611381565b606063dd62ed3e60e01b83836040516024016111ad929190611946565b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b0319909316929092179091529392505050565b6000818060200190518101906105419190611704565b606063095ea7b360e01b83836040516024016111ad9291906119a7565b604080516000815260208101909152606090819061123a90604481016119c0565b60408051601f198184030181529190526020810180516001600160e01b03166352e831dd60e01b179052805190915060630167ffffffffffffffff8111801561128257600080fd5b506040519080825280601f01601f1916602001820160405280156112ad576020820181803683370190505b507f3d3d606380380380913d393d73bebebebebebebebebebebebebebebebebebebe6020820152600160601b858102602d8301527f5af4602a57600080fd5b602d8060366000396000f3363d3d373d3d3d363d73be6041830152840260608201526e5af43d82803e903d91602b57fd5bf360881b6074820152915060005b81518110156113795781818151811061134057fe5b602001015160f81c60f81b83826063018151811061135a57fe5b60200101906001600160f81b031916908160001a90535060010161132b565b505092915050565b60008060ff60f81b83868660405160200161139f9493929190611857565b60408051808303601f19018152919052805160209091012095945050505050565bfe5b6040518060a0016040528060008152602001600081526020016060815260200160006001600160a01b03168152602001600081525090565b6040518060800160405280600081526020016060815260200160006001600160a01b03168152602001600081525090565b604080518082019091526000808252602082015290565b60405180606001604052806000815260200160008152602001600081525090565b803561054181611c49565b600082601f83011261147e578081fd5b815167ffffffffffffffff811115611494578182fd5b60208082026114a4828201611bf2565b838152935081840185830182870184018810156114c057600080fd5b600092505b848310156114ec5780516114d881611c49565b8252600192909201919083019083016114c5565b505050505092915050565b600082601f830112611507578081fd5b813567ffffffffffffffff81111561151d578182fd5b611530601f8201601f1916602001611bf2565b915080825283602082850101111561154757600080fd5b8060208401602084013760009082016020015292915050565b600060208284031215611571578081fd5b815161059d81611c49565b60006020828403121561158d578081fd5b813567ffffffffffffffff808211156115a4578283fd5b6101009184018086038313156115b8578384fd5b6115c183611bf2565b6115cb8783611463565b81526115da8760208401611463565b60208201526115ec8760408401611463565b60408201526115fe8760608401611463565b60608201526116108760808401611463565b60808201526116228760a08401611463565b60a082015260c082013560c082015260e0820135935082841115611644578485fd5b611650878584016114f7565b60e08201529695505050505050565b600060408284031215611670578081fd5b61167a6040611bf2565b82518152602083015161168c81611c49565b60208201529392505050565b6000608082840312156116a9578081fd5b6116b36080611bf2565b825180151581146116c2578283fd5b815260208301516116d281611c49565b602082015260408301516116e581611c49565b604082015260608301516116f881611c49565b60608201529392505050565b600060208284031215611715578081fd5b5051919050565b60008060008060808587031215611731578283fd5b84519350602085015167ffffffffffffffff81111561174e578384fd5b61175a8782880161146e565b935050604085015161176b81611c49565b6060959095015193969295505050565b600080600080600060a08688031215611792578081fd5b8551945060208601519350604086015167ffffffffffffffff8111156117b6578182fd5b6117c28882890161146e565b93505060608601516117d381611c49565b80925050608086015190509295509295909350565b6000815180845260208085019450808401835b838110156118205781516001600160a01b0316875295820195908201906001016117fb565b509495945050505050565b60008151808452611843816020860160208601611c19565b601f01601f19169290920160200192915050565b6001600160f81b031994909416845260609290921b6001600160601b03191660018401526015830152603582015260550190565b92835260609190911b6001600160601b0319166020830152603482015260540190565b600082516118c0818460208701611c19565b9190910192915050565b7f69736f6c6174652e756e69737761702d76322d61646170746572000000000000815260609190911b6001600160601b031916601a820152602e0190565b7434b9b7b630ba329732b931991816b0b230b83a32b960591b815260150190565b90815260200190565b6001600160a01b0391909116815260200190565b6001600160a01b0392831681529116602082015260400190565b6001600160a01b039290921682526001600160e01b031916602082015260400190565b6001600160a01b0383168152604060208201819052600090610bc89083018461182b565b6001600160a01b03929092168252602082015260400190565b60006020825261059d602083018461182b565b6020808252602a908201527f70617468206d7573742062652032206f722033206974656d7320616e6420696e6040820152690c6d8eac8ca40ae8aa8960b31b606082015260800190565b60208082526019908201527f756e737570706f7274656420636f6e74726163742063616c6c00000000000000604082015260600190565b6020808252602d908201527f6173736574206973206e6f74206173736f63696174656420776974682074686560408201526c204552433230206d6f64756c6560981b606082015260800190565b60208082526022908201527f7061746820746f6f2073686f72742c206d757374206265203320656c656d656e604082015261747360f01b606082015260800190565b60208082526027908201527f6c69717569646174696f6e206d6f64756c65206e6f74696669636174696f6e206040820152666661696c75726560c81b606082015260800190565b6020808252601d908201527f6661696c656420746f20617070726f766520737461727420746f6b656e000000604082015260600190565b815181526020918201516001600160a01b03169181019190915260400190565b600085825260806020830152611b9a60808301866117e8565b6001600160a01b03949094166040830152506060015292915050565b600086825285602083015260a06040830152611bd560a08301866117e8565b6001600160a01b0394909416606083015250608001529392505050565b60405181810167ffffffffffffffff81118282101715611c1157600080fd5b604052919050565b60005b83811015611c34578181015183820152602001611c1c565b83811115611c43576000848401525b50505050565b6001600160a01b0381168114611c5e57600080fd5b5056fea26469706673582212208c2b17afe2e63caaac80e387f9fa62b2234f0f96217ecafacd5624924e52789764736f6c634300060a0033",
  "deployedBytecode": "0x6080604052600436106100295760003560e01c80633c52e5a11461002e578063966ff7a814610043575b600080fd5b61004161003c36600461157c565b61006e565b005b34801561004f57600080fd5b506100586104f6565b6040516100659190611b61565b60405180910390f35b6000606061007f8360e0015161054a565b909250905060008061009081610582565b90506000806001600160e01b031986166338ed173960e01b141561013e576100b66113c2565b6100bf866105a4565b905060006100cc89610602565b60408301519091506100e4908263ffffffff61067916565b945092506100f28985610759565b5060608201516001600160a01b031630146101375761011f61011a838763ffffffff61083316565b610883565b60e08a015260608201516001965061013790856108f2565b50506103c0565b6001600160e01b03198616634401edf760e11b14156101c85761015f6113c2565b610168866105a4565b9050600061017589610602565b604083015190915061018d908263ffffffff61067916565b9450925061019b8985610759565b5060608201516001600160a01b031630146101375761011f6101c3838763ffffffff61083316565b610964565b6001600160e01b03198616637ff36ab560e01b141561026a576101e96113fa565b6101f28661099b565b905060006101ff89610602565b6020830151909150610217908263ffffffff61067916565b945092506102258985610759565b5060408201516001600160a01b031630146101375761025261024d838763ffffffff6109f516565b610a35565b60e08a015260408201516001965061013790856108f2565b6001600160e01b03198616632512eca560e11b141561028b576101e96113fa565b6001600160e01b031986166318cbafe560e01b1415610315576102ac6113c2565b6102b5866105a4565b905060006102c289610602565b60408301519091506102da908263ffffffff61067916565b945092506102e88985610759565b5060608201516001600160a01b031630146101375761011f610310838763ffffffff61083316565b610a66565b6001600160e01b0319861663fb3bdb4160e01b141561039f576103366113fa565b61033f8661099b565b9050600061034c89610602565b6020830151909150610364908263ffffffff61067916565b945092506103728985610759565b5060408201516001600160a01b031630146101375761025261039a838763ffffffff6109f516565b610a9d565b60405162461bcd60e51b81526004016103b790611a1d565b60405180910390fd5b6001600160a01b0382161561041a576103fe6103e4836001600160a01b0316610ace565b60208901516001600160a01b03169063ffffffff610af716565b61041a5760405162461bcd60e51b81526004016103b790611ae3565b60a0870151610439906001600160a01b0383169063ffffffff610b6616565b6104555760405162461bcd60e51b81526004016103b790611b2a565b831561046f57865161046f9060009063ffffffff610bd016565b600060608860a001516001600160a01b03165a8a60c001518b60e0015160405161049991906118ae565b600060405180830381858888f193505050503d80600081146104d7576040519150601f19603f3d011682016040523d82523d6000602084013e6104dc565b606091505b50915091506104eb8282610c69565b505050505050505050565b6104fe61142b565b6105073061052e565b60408051808201909152815481526001909101546001600160a01b03166020820152905090565b600061054161053c83610c7e565b610caf565b92915050565b90565b6000606061056361055e8460006004610cc5565b610cee565b60e01b915061057b610576846004610d03565b610d27565b9050915091565b60008061058d610d97565b805490915061059d908490610da9565b9392505050565b6105ac6113c2565b6000806060600080868060200190518101906105c8919061177b565b6040805160a0810182529586526020860194909452928401919091526001600160a01b031660608301526080820152979650505050505050565b60008160a001516001600160a01b031663ad5c46486040518163ffffffff1660e01b815260040160206040518083038186803b15801561064157600080fd5b505afa158015610655573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105419190611560565b60008060028451101561069e5760405162461bcd60e51b81526004016103b790611aa1565b6003845111806107045750826001600160a01b0316846000815181106106c057fe5b60200260200101516001600160a01b031614806107025750826001600160a01b0316846001815181106106ef57fe5b60200260200101516001600160a01b0316145b155b156107215760405162461bcd60e51b81526004016103b7906119d3565b8360008151811061072e57fe5b60200260200101518460018651038151811061074657fe5b6020026020010151915091509250929050565b600061076361142b565b835161076e90610e6c565b6020810151600054604051630220891b60e51b81529293506001600160a01b03918216929116906344112360906107b290879063a9059cbb60e01b90600401611960565b60806040518083038186803b1580156107ca57600080fd5b505afa1580156107de573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108029190611698565b602001516001600160a01b03161461082c5760405162461bcd60e51b81526004016103b790611a54565b5092915050565b61083b6113c2565b6040518060a00160405280846000015181526020018460200151815260200184604001518152602001836001600160a01b031681526020018460800151815250905092915050565b60606338ed173960e01b826000015183602001518460400151856060015186608001516040516024016108ba959493929190611bb6565b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b03199093169290921790915292915050565b60006108fc610d97565b604080518082019091526001600160a01b03948516815292841660208085019182528254600181810185556000948552919093209451600290930290940180549286166001600160a01b03199384161781559051930180549390941692169190911790915550565b6060638803dbee60e01b826000015183602001518460400151856060015186608001516040516024016108ba959493929190611bb6565b6109a36113fa565b60006060600080858060200190518101906109be919061171c565b6040805160808101825294855260208501939093526001600160a01b03909116918301919091526060820152945050505050919050565b6109fd6113fa565b506040805160808101825283518152602080850151908201526001600160a01b03909216908201526060918201519181019190915290565b6060637ff36ab560e01b82600001518360200151846040015185606001516040516024016108ba9493929190611b81565b60606318cbafe560e01b826000015183602001518460400151856060015186608001516040516024016108ba959493929190611bb6565b606063fb3bdb4160e01b82600001518360200151846040015185606001516040516024016108ba9493929190611b81565b606081604051602001610ae19190611932565b6040516020818303038152906040529050919050565b600080836001600160a01b0316610b0e8585610ee4565b604051610b1b91906118ae565b600060405180830381855af49150503d8060008114610b56576040519150601f19603f3d011682016040523d82523d6000602084013e610b5b565b606091505b509095945050505050565b600080610b74843085610f2a565b90506001600160fe1b03811115610b8f576001915050610541565b8015801590610ba75750610ba584306000610fc9565b155b15610bb6576000915050610541565b610bc884846001600160ff1b03610fc9565b949350505050565b610bd861142b565b816001600160a01b031663966ff7a86040518163ffffffff1660e01b8152600401604080518083038186803b158015610c1057600080fd5b505afa158015610c24573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c48919061165f565b9050610c6481602001518460090161103b90919063ffffffff16565b505050565b81610c7657805181602001fd5b805181602001f35b600081604051602001610c9191906118ca565b60408051601f19818403018152919052805160209091012092915050565b600061054182610cbd611095565b63ffffffff16565b610ccd611442565b610cd7848461109b565b815260208101919091526040810191909152919050565b8051602082015160009190610bc882826110a2565b610d0b611442565b8183511015610d1957825191505b61059d838384865103610cc5565b60208101516060908067ffffffffffffffff81118015610d4657600080fd5b506040519080825280601f01601f191660200182016040528015610d71576020820181803683370190505b5083519092506000610d82846110bf565b9050610d8f8183856110c5565b505050919050565b6000610da461053c611103565b905090565b8154604080516332dd41bd60e11b8152905160009261059d926001600160a01b039091169182916365ba837a916004808301926020929190829003018186803b158015610df557600080fd5b505afa158015610e09573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e2d9190611560565b610e3561111f565b30610e3f87611143565b604051602001610e519392919061188b565b60405160208183030381529060405280519060200120611173565b610e7461142b565b816001600160a01b031663966ff7a86040518163ffffffff1660e01b8152600401604080518083038186803b158015610eac57600080fd5b505afa158015610ec0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610541919061165f565b60608282604051602401610ef9929190611983565b60408051601f198184030181529190526020810180516001600160e01b0316633e87f4a360e21b1790529392505050565b6000806060856001600160a01b0316610f438686611190565b604051610f5091906118ae565b6000604051808303816000865af19150503d8060008114610f8d576040519150601f19603f3d011682016040523d82523d6000602084013e610f92565b606091505b5091509150811580610fa657508051602014155b15610fb65760019250505061059d565b610fbf816111e6565b9695505050505050565b600080846001600160a01b0316610fe085856111fc565b604051610fed91906118ae565b6000604051808303816000865af19150503d806000811461102a576040519150601f19603f3d011682016040523d82523d6000602084013e61102f565b606091505b50909695505050505050565b6001600160a01b03811660009081526020839052604090205460ff161561106157611091565b6001828101805491820181556000908152602090200180546001600160a01b0319166001600160a01b0383161790555b5050565b61054790565b0160200190565b6000600180600884021b0380836020038503511691505092915050565b60200190565b5b602081106110e5578151835260209283019290910190601f19016110c6565b600180600883602003021b0380845116811984511617845250505050565b600060405161111190611908565b604051908190039020905090565b7f6b6f6b75258f8f4cdb6ef275682bc2be3e8b970e5e4417113bd1ea53622d907e90565b6000816040516020016111569190611929565b604051602081830303815290604052805190602001209050919050565b6000610bc8826111838686611219565b8051906020012086611381565b606063dd62ed3e60e01b83836040516024016111ad929190611946565b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b0319909316929092179091529392505050565b6000818060200190518101906105419190611704565b606063095ea7b360e01b83836040516024016111ad9291906119a7565b604080516000815260208101909152606090819061123a90604481016119c0565b60408051601f198184030181529190526020810180516001600160e01b03166352e831dd60e01b179052805190915060630167ffffffffffffffff8111801561128257600080fd5b506040519080825280601f01601f1916602001820160405280156112ad576020820181803683370190505b507f3d3d606380380380913d393d73bebebebebebebebebebebebebebebebebebebe6020820152600160601b858102602d8301527f5af4602a57600080fd5b602d8060366000396000f3363d3d373d3d3d363d73be6041830152840260608201526e5af43d82803e903d91602b57fd5bf360881b6074820152915060005b81518110156113795781818151811061134057fe5b602001015160f81c60f81b83826063018151811061135a57fe5b60200101906001600160f81b031916908160001a90535060010161132b565b505092915050565b60008060ff60f81b83868660405160200161139f9493929190611857565b60408051808303601f19018152919052805160209091012095945050505050565bfe5b6040518060a0016040528060008152602001600081526020016060815260200160006001600160a01b03168152602001600081525090565b6040518060800160405280600081526020016060815260200160006001600160a01b03168152602001600081525090565b604080518082019091526000808252602082015290565b60405180606001604052806000815260200160008152602001600081525090565b803561054181611c49565b600082601f83011261147e578081fd5b815167ffffffffffffffff811115611494578182fd5b60208082026114a4828201611bf2565b838152935081840185830182870184018810156114c057600080fd5b600092505b848310156114ec5780516114d881611c49565b8252600192909201919083019083016114c5565b505050505092915050565b600082601f830112611507578081fd5b813567ffffffffffffffff81111561151d578182fd5b611530601f8201601f1916602001611bf2565b915080825283602082850101111561154757600080fd5b8060208401602084013760009082016020015292915050565b600060208284031215611571578081fd5b815161059d81611c49565b60006020828403121561158d578081fd5b813567ffffffffffffffff808211156115a4578283fd5b6101009184018086038313156115b8578384fd5b6115c183611bf2565b6115cb8783611463565b81526115da8760208401611463565b60208201526115ec8760408401611463565b60408201526115fe8760608401611463565b60608201526116108760808401611463565b60808201526116228760a08401611463565b60a082015260c082013560c082015260e0820135935082841115611644578485fd5b611650878584016114f7565b60e08201529695505050505050565b600060408284031215611670578081fd5b61167a6040611bf2565b82518152602083015161168c81611c49565b60208201529392505050565b6000608082840312156116a9578081fd5b6116b36080611bf2565b825180151581146116c2578283fd5b815260208301516116d281611c49565b602082015260408301516116e581611c49565b604082015260608301516116f881611c49565b60608201529392505050565b600060208284031215611715578081fd5b5051919050565b60008060008060808587031215611731578283fd5b84519350602085015167ffffffffffffffff81111561174e578384fd5b61175a8782880161146e565b935050604085015161176b81611c49565b6060959095015193969295505050565b600080600080600060a08688031215611792578081fd5b8551945060208601519350604086015167ffffffffffffffff8111156117b6578182fd5b6117c28882890161146e565b93505060608601516117d381611c49565b80925050608086015190509295509295909350565b6000815180845260208085019450808401835b838110156118205781516001600160a01b0316875295820195908201906001016117fb565b509495945050505050565b60008151808452611843816020860160208601611c19565b601f01601f19169290920160200192915050565b6001600160f81b031994909416845260609290921b6001600160601b03191660018401526015830152603582015260550190565b92835260609190911b6001600160601b0319166020830152603482015260540190565b600082516118c0818460208701611c19565b9190910192915050565b7f69736f6c6174652e756e69737761702d76322d61646170746572000000000000815260609190911b6001600160601b031916601a820152602e0190565b7434b9b7b630ba329732b931991816b0b230b83a32b960591b815260150190565b90815260200190565b6001600160a01b0391909116815260200190565b6001600160a01b0392831681529116602082015260400190565b6001600160a01b039290921682526001600160e01b031916602082015260400190565b6001600160a01b0383168152604060208201819052600090610bc89083018461182b565b6001600160a01b03929092168252602082015260400190565b60006020825261059d602083018461182b565b6020808252602a908201527f70617468206d7573742062652032206f722033206974656d7320616e6420696e6040820152690c6d8eac8ca40ae8aa8960b31b606082015260800190565b60208082526019908201527f756e737570706f7274656420636f6e74726163742063616c6c00000000000000604082015260600190565b6020808252602d908201527f6173736574206973206e6f74206173736f63696174656420776974682074686560408201526c204552433230206d6f64756c6560981b606082015260800190565b60208082526022908201527f7061746820746f6f2073686f72742c206d757374206265203320656c656d656e604082015261747360f01b606082015260800190565b60208082526027908201527f6c69717569646174696f6e206d6f64756c65206e6f74696669636174696f6e206040820152666661696c75726560c81b606082015260800190565b6020808252601d908201527f6661696c656420746f20617070726f766520737461727420746f6b656e000000604082015260600190565b815181526020918201516001600160a01b03169181019190915260400190565b600085825260806020830152611b9a60808301866117e8565b6001600160a01b03949094166040830152506060015292915050565b600086825285602083015260a06040830152611bd560a08301866117e8565b6001600160a01b0394909416606083015250608001529392505050565b60405181810167ffffffffffffffff81118282101715611c1157600080fd5b604052919050565b60005b83811015611c34578181015183820152602001611c1c565b83811115611c43576000848401525b50505050565b6001600160a01b0381168114611c5e57600080fd5b5056fea26469706673582212208c2b17afe2e63caaac80e387f9fa62b2234f0f96217ecafacd5624924e52789764736f6c634300060a0033",
  "libraries": {},
  "devdoc": {
    "methods": {}
  },
  "userdoc": {
    "methods": {}
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 8046,
        "contract": "contracts/adapters/assets/uniswap-v2/UniswapV2Adapter.sol:UniswapV2Adapter",
        "label": "proxyIsolate",
        "offset": 0,
        "slot": "0",
        "type": "t_struct(ProxyIsolate)2329_storage"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_address_payable": {
        "encoding": "inplace",
        "label": "address payable",
        "numberOfBytes": "20"
      },
      "t_array(t_address)dyn_storage": {
        "base": "t_address",
        "encoding": "dynamic_array",
        "label": "address[]",
        "numberOfBytes": "32"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_struct(AddressSet)11747_storage": {
        "encoding": "inplace",
        "label": "struct AddressSetLib.AddressSet",
        "members": [
          {
            "astId": 11743,
            "contract": "contracts/adapters/assets/uniswap-v2/UniswapV2Adapter.sol:UniswapV2Adapter",
            "label": "uniq",
            "offset": 0,
            "slot": "0",
            "type": "t_mapping(t_address,t_bool)"
          },
          {
            "astId": 11746,
            "contract": "contracts/adapters/assets/uniswap-v2/UniswapV2Adapter.sol:UniswapV2Adapter",
            "label": "set",
            "offset": 0,
            "slot": "1",
            "type": "t_array(t_address)dyn_storage"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(ProxyIsolate)2329_storage": {
        "encoding": "inplace",
        "label": "struct BorrowProxyLib.ProxyIsolate",
        "members": [
          {
            "astId": 2308,
            "contract": "contracts/adapters/assets/uniswap-v2/UniswapV2Adapter.sol:UniswapV2Adapter",
            "label": "masterAddress",
            "offset": 0,
            "slot": "0",
            "type": "t_address_payable"
          },
          {
            "astId": 2310,
            "contract": "contracts/adapters/assets/uniswap-v2/UniswapV2Adapter.sol:UniswapV2Adapter",
            "label": "unbound",
            "offset": 20,
            "slot": "0",
            "type": "t_bool"
          },
          {
            "astId": 2312,
            "contract": "contracts/adapters/assets/uniswap-v2/UniswapV2Adapter.sol:UniswapV2Adapter",
            "label": "owner",
            "offset": 0,
            "slot": "1",
            "type": "t_address"
          },
          {
            "astId": 2314,
            "contract": "contracts/adapters/assets/uniswap-v2/UniswapV2Adapter.sol:UniswapV2Adapter",
            "label": "token",
            "offset": 0,
            "slot": "2",
            "type": "t_address"
          },
          {
            "astId": 2316,
            "contract": "contracts/adapters/assets/uniswap-v2/UniswapV2Adapter.sol:UniswapV2Adapter",
            "label": "actualizedShift",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          },
          {
            "astId": 2318,
            "contract": "contracts/adapters/assets/uniswap-v2/UniswapV2Adapter.sol:UniswapV2Adapter",
            "label": "liquidationIndex",
            "offset": 0,
            "slot": "4",
            "type": "t_uint256"
          },
          {
            "astId": 2320,
            "contract": "contracts/adapters/assets/uniswap-v2/UniswapV2Adapter.sol:UniswapV2Adapter",
            "label": "repaymentIndex",
            "offset": 0,
            "slot": "5",
            "type": "t_uint256"
          },
          {
            "astId": 2322,
            "contract": "contracts/adapters/assets/uniswap-v2/UniswapV2Adapter.sol:UniswapV2Adapter",
            "label": "isRepaying",
            "offset": 0,
            "slot": "6",
            "type": "t_bool"
          },
          {
            "astId": 2324,
            "contract": "contracts/adapters/assets/uniswap-v2/UniswapV2Adapter.sol:UniswapV2Adapter",
            "label": "isLiquidating",
            "offset": 1,
            "slot": "6",
            "type": "t_bool"
          },
          {
            "astId": 2326,
            "contract": "contracts/adapters/assets/uniswap-v2/UniswapV2Adapter.sol:UniswapV2Adapter",
            "label": "liquidationSet",
            "offset": 0,
            "slot": "7",
            "type": "t_struct(AddressSet)11747_storage"
          },
          {
            "astId": 2328,
            "contract": "contracts/adapters/assets/uniswap-v2/UniswapV2Adapter.sol:UniswapV2Adapter",
            "label": "repaymentSet",
            "offset": 0,
            "slot": "9",
            "type": "t_struct(AddressSet)11747_storage"
          }
        ],
        "numberOfBytes": "352"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  },
  "gasEstimates": {
    "creation": {
      "codeDepositCost": "1463800",
      "executionCost": "infinite",
      "totalCost": "infinite"
    },
    "external": {
      "getExternalIsolateHandler()": "infinite",
      "handle((address,address,address,address,address,address,uint256,bytes))": "infinite"
    },
    "internal": {
      "getWETH(struct ModuleLib.AssetSubmodulePayload memory)": "infinite",
      "validateIsERC20Module(struct ModuleLib.AssetSubmodulePayload memory,address)": "infinite"
    }
  }
}